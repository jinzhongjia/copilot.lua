# zbirenbaum/copilot.lua ä¸­é›†æˆ Next Edit Suggestions çš„å®Œæ•´æŒ‡å—

**ä½œè€…**: Manus AI  
**ç‰ˆæœ¬**: 1.0  
**æ—¥æœŸ**: 2025å¹´6æœˆ25æ—¥

## ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [å‰ç½®è¦æ±‚](#å‰ç½®è¦æ±‚)
3. [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
4. [æ ¸å¿ƒæ¨¡å—å®ç°](#æ ¸å¿ƒæ¨¡å—å®ç°)
5. [LSP é›†æˆæ‰©å±•](#lsp-é›†æˆæ‰©å±•)
6. [ç”¨æˆ·ç•Œé¢å®ç°](#ç”¨æˆ·ç•Œé¢å®ç°)
7. [é…ç½®ç³»ç»Ÿ](#é…ç½®ç³»ç»Ÿ)
8. [å®‰è£…å’Œé…ç½®](#å®‰è£…å’Œé…ç½®)
9. [ä½¿ç”¨æŒ‡å—](#ä½¿ç”¨æŒ‡å—)
10. [æ•…éšœæ’é™¤](#æ•…éšœæ’é™¤)
11. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
12. [æ‰©å±•å¼€å‘](#æ‰©å±•å¼€å‘)

## æ¦‚è¿°

Next Edit Suggestions (NES) æ˜¯ GitHub Copilot Language Server çš„ä¸€é¡¹åˆ›æ–°åŠŸèƒ½ï¼Œä¸“é—¨ç”¨äºæ™ºèƒ½ç¼–è¾‘ç°æœ‰ä»£ç ã€‚ä¸ä¼ ç»Ÿçš„ä»£ç è‡ªåŠ¨è¡¥å…¨ä¸åŒï¼ŒNES åŸºäºä¸Šä¸‹æ–‡æ„ŸçŸ¥çš„é¢„æµ‹æ€§ç¼–è¾‘ï¼Œèƒ½å¤Ÿé¢„æµ‹å¼€å‘è€…ä¸‹ä¸€æ­¥å¯èƒ½éœ€è¦çš„ä»£ç ä¿®æ”¹ï¼ŒåŒ…æ‹¬é”™è¯¯ä¿®å¤ã€ä»£ç é‡æ„ã€å˜é‡é‡å‘½åç­‰æ“ä½œã€‚

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»äº†å¦‚ä½•åœ¨ zbirenbaum/copilot.lua æ’ä»¶ä¸­é›†æˆ Next Edit Suggestions åŠŸèƒ½ã€‚é€šè¿‡æœ¬æŒ‡å—ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- ç†è§£ NES åŠŸèƒ½çš„å·¥ä½œåŸç†å’ŒæŠ€æœ¯æ¶æ„
- æŒæ¡åœ¨ copilot.lua ä¸­é›†æˆ NES çš„å®Œæ•´å®ç°æ–¹æ³•
- å­¦ä¼šé…ç½®å’Œè‡ªå®šä¹‰ NES åŠŸèƒ½ä»¥æ»¡è¶³ä¸ªäººéœ€æ±‚
- äº†è§£å¦‚ä½•ä¼˜åŒ– NES æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒ
- æŒæ¡æ•…éšœæ’é™¤å’Œé—®é¢˜è¯Šæ–­çš„æ–¹æ³•

### NES åŠŸèƒ½ç‰¹ç‚¹

Next Edit Suggestions å…·æœ‰ä»¥ä¸‹æ ¸å¿ƒç‰¹ç‚¹ï¼š

**æ™ºèƒ½é¢„æµ‹æ€§ç¼–è¾‘**: NES ä¸ä»…ä»…æ˜¯ä»£ç è¡¥å…¨ï¼Œè€Œæ˜¯åŸºäºä»£ç ä¸Šä¸‹æ–‡å’Œå¼€å‘è€…è¡Œä¸ºæ¨¡å¼çš„æ™ºèƒ½ç¼–è¾‘å»ºè®®ã€‚å®ƒèƒ½å¤Ÿåˆ†æå½“å‰ä»£ç çŠ¶æ€ï¼Œé¢„æµ‹å¼€å‘è€…å¯èƒ½éœ€è¦è¿›è¡Œçš„ä¿®æ”¹æ“ä½œã€‚

**å¤šåœºæ™¯é€‚ç”¨æ€§**: NES é€‚ç”¨äºå¤šç§ç¼–ç¨‹åœºæ™¯ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºé”™è¯¯ä¿®å¤ã€ä»£ç é‡æ„ã€å˜é‡é‡å‘½åã€é€»è¾‘ä¼˜åŒ–ã€ä»£ç é£æ ¼è°ƒæ•´ç­‰ã€‚è¿™ä½¿å¾—å®ƒæˆä¸ºä¸€ä¸ªå…¨æ–¹ä½çš„ç¼–ç¨‹åŠ©æ‰‹ã€‚

**ä¸Šä¸‹æ–‡æ„ŸçŸ¥**: NES å……åˆ†åˆ©ç”¨æ–‡ä»¶å†…å®¹ã€é¡¹ç›®ç»“æ„ã€ç¼–ç¨‹è¯­è¨€ç‰¹æ€§ç­‰ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œæä¾›æ›´åŠ ç²¾å‡†å’Œç›¸å…³çš„ç¼–è¾‘å»ºè®®ã€‚

**éä¾µå…¥å¼é›†æˆ**: NES è®¾è®¡ä¸ºä¸ç°æœ‰çš„ä»£ç è¡¥å…¨åŠŸèƒ½å¹¶è¡Œå·¥ä½œï¼Œä¸ä¼šå¹²æ‰°ä¼ ç»Ÿçš„ç¼–ç¨‹å·¥ä½œæµç¨‹ã€‚

### æŠ€æœ¯èƒŒæ™¯

NES åŠŸèƒ½åŸºäº Language Server Protocol (LSP) å®ç°ï¼Œé€šè¿‡æ‰©å±•æ ‡å‡† LSP åè®®æ¥æ”¯æŒé¢„æµ‹æ€§ç¼–è¾‘åŠŸèƒ½ã€‚ä¸»è¦æ¶‰åŠä»¥ä¸‹æŠ€æœ¯ç»„ä»¶ï¼š

**LSP åè®®æ‰©å±•**: NES ä½¿ç”¨è‡ªå®šä¹‰çš„ LSP æ¶ˆæ¯ç±»å‹æ¥ä¼ é€’ç¼–è¾‘å»ºè®®ï¼ŒåŒ…æ‹¬ `textDocument/publishNextEditSuggestions` é€šçŸ¥å’Œç›¸å…³çš„å‘½ä»¤å¤„ç†ã€‚

**äº‹ä»¶é©±åŠ¨æ¶æ„**: NES é€šè¿‡ç›‘å¬æ–‡æ¡£å˜åŒ–äº‹ä»¶æ¥è§¦å‘å»ºè®®ç”Ÿæˆï¼Œé‡‡ç”¨äº‹ä»¶é©±åŠ¨çš„æ¶æ„æ¨¡å¼ç¡®ä¿åŠæ—¶å“åº”ç”¨æˆ·æ“ä½œã€‚

**å¼‚æ­¥å¤„ç†æœºåˆ¶**: ä¸ºäº†é¿å…é˜»å¡ç”¨æˆ·ç•Œé¢ï¼ŒNES é‡‡ç”¨å¼‚æ­¥å¤„ç†æœºåˆ¶æ¥ç”Ÿæˆå’Œæ˜¾ç¤ºå»ºè®®ï¼Œç¡®ä¿æµç•…çš„ç”¨æˆ·ä½“éªŒã€‚

## å‰ç½®è¦æ±‚

åœ¨å¼€å§‹é›†æˆ Next Edit Suggestions åŠŸèƒ½ä¹‹å‰ï¼Œè¯·ç¡®ä¿æ‚¨çš„å¼€å‘ç¯å¢ƒæ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼š

### è½¯ä»¶è¦æ±‚

**Neovim ç‰ˆæœ¬**: éœ€è¦ Neovim 0.10.0 æˆ–æ›´é«˜ç‰ˆæœ¬ã€‚NES åŠŸèƒ½ä¾èµ–äº Neovim çš„ç°ä»£ LSP å®¢æˆ·ç«¯å®ç°å’Œæµ®åŠ¨çª—å£åŠŸèƒ½ã€‚

**Node.js ç¯å¢ƒ**: éœ€è¦ Node.js v20 æˆ–æ›´é«˜ç‰ˆæœ¬ã€‚GitHub Copilot Language Server åŸºäº Node.js è¿è¡Œï¼Œéœ€è¦ç°ä»£çš„ JavaScript è¿è¡Œæ—¶ç¯å¢ƒã€‚

**GitHub Copilot Language Server**: éœ€è¦å®‰è£… @github/copilot-language-server 1.337.0 æˆ–æ›´é«˜ç‰ˆæœ¬ã€‚è¿™ä¸ªç‰ˆæœ¬åŒ…å«äº† Next Edit Suggestions åŠŸèƒ½çš„å®Œæ•´å®ç°ã€‚

**copilot.lua æ’ä»¶**: éœ€è¦ zbirenbaum/copilot.lua æ’ä»¶ä½œä¸ºåŸºç¡€ã€‚æœ¬æŒ‡å—åŸºäºè¯¥æ’ä»¶çš„æ¶æ„è¿›è¡Œæ‰©å±•ã€‚

### ä¾èµ–åº“è¦æ±‚

**Lua æ¨¡å—**: éœ€è¦ç¡®ä¿ Neovim çš„ Lua ç¯å¢ƒåŒ…å«å¿…è¦çš„æ¨¡å—ï¼ŒåŒ…æ‹¬ `vim.lsp`ã€`vim.api`ã€`vim.fn` ç­‰æ ¸å¿ƒæ¨¡å—ã€‚

**LSP å®¢æˆ·ç«¯**: éœ€è¦ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„ LSP å®¢æˆ·ç«¯å®ç°ï¼Œæ”¯æŒè‡ªå®šä¹‰æ¶ˆæ¯å¤„ç†å’Œäº‹ä»¶ç›‘å¬ã€‚

### æƒé™è¦æ±‚

**GitHub Copilot è®¢é˜…**: éœ€è¦æœ‰æ•ˆçš„ GitHub Copilot è®¢é˜…ã€‚NES åŠŸèƒ½æ˜¯ GitHub Copilot çš„é«˜çº§åŠŸèƒ½ï¼Œéœ€è¦ç›¸åº”çš„æˆæƒã€‚

**ç½‘ç»œè®¿é—®**: éœ€è¦ç¨³å®šçš„ç½‘ç»œè¿æ¥ä»¥è®¿é—® GitHub Copilot æœåŠ¡ã€‚NES åŠŸèƒ½éœ€è¦ä¸ GitHub çš„æœåŠ¡å™¨è¿›è¡Œå®æ—¶é€šä¿¡ã€‚

### éªŒè¯ç¯å¢ƒ

åœ¨å¼€å§‹å®æ–½ä¹‹å‰ï¼Œå»ºè®®è¿è¡Œä»¥ä¸‹å‘½ä»¤éªŒè¯ç¯å¢ƒï¼š

```bash
# æ£€æŸ¥ Neovim ç‰ˆæœ¬
nvim --version

# æ£€æŸ¥ Node.js ç‰ˆæœ¬  
node --version

# æ£€æŸ¥ npm ç‰ˆæœ¬
npm --version

# éªŒè¯ GitHub Copilot Language Server å®‰è£…
npm list -g @github/copilot-language-server
```

ç¡®ä¿æ‰€æœ‰ç»„ä»¶éƒ½æ»¡è¶³ç‰ˆæœ¬è¦æ±‚åï¼Œå³å¯å¼€å§‹ NES åŠŸèƒ½çš„é›†æˆå·¥ä½œã€‚


## æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„æ¦‚è§ˆ

Next Edit Suggestions çš„é›†æˆé‡‡ç”¨æ¨¡å—åŒ–æ¶æ„è®¾è®¡ï¼Œåœ¨ä¿æŒä¸ç°æœ‰ copilot.lua æ’ä»¶å…¼å®¹çš„åŒæ—¶ï¼Œæ·»åŠ æ–°çš„ NES åŠŸèƒ½æ¨¡å—ã€‚æ•´ä½“æ¶æ„éµå¾ªå•ä¸€èŒè´£åŸåˆ™å’Œå¼€æ”¾å°é—­åŸåˆ™ï¼Œç¡®ä¿åŠŸèƒ½çš„å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

æ¶æ„è®¾è®¡çš„æ ¸å¿ƒæ€æƒ³æ˜¯å°† NES åŠŸèƒ½ä½œä¸ºä¸€ä¸ªç‹¬ç«‹çš„æ¨¡å—é›†æˆåˆ°ç°æœ‰çš„æ’ä»¶æ¶æ„ä¸­ï¼Œé€šè¿‡æ˜ç¡®å®šä¹‰çš„æ¥å£ä¸å…¶ä»–æ¨¡å—è¿›è¡Œäº¤äº’ã€‚è¿™ç§è®¾è®¡æ–¹å¼å…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

**æ¨¡å—åŒ–è®¾è®¡**: æ¯ä¸ªåŠŸèƒ½æ¨¡å—éƒ½æœ‰æ˜ç¡®çš„èŒè´£è¾¹ç•Œï¼Œä¾¿äºç‹¬ç«‹å¼€å‘ã€æµ‹è¯•å’Œç»´æŠ¤ã€‚NES æ¨¡å—å¯ä»¥ç‹¬ç«‹äºå…¶ä»–åŠŸèƒ½æ¨¡å—è¿›è¡Œå¼€å‘å’Œè°ƒè¯•ã€‚

**æ¾è€¦åˆæ¶æ„**: æ¨¡å—ä¹‹é—´é€šè¿‡å®šä¹‰è‰¯å¥½çš„æ¥å£è¿›è¡Œé€šä¿¡ï¼Œå‡å°‘äº†æ¨¡å—é—´çš„ä¾èµ–å…³ç³»ã€‚è¿™ä½¿å¾—ç³»ç»Ÿæ›´åŠ çµæ´»ï¼Œä¾¿äºåç»­çš„åŠŸèƒ½æ‰©å±•å’Œä¿®æ”¹ã€‚

**å¯æ’æ‹”è®¾è®¡**: NES åŠŸèƒ½å¯ä»¥ä½œä¸ºå¯é€‰æ¨¡å—è¿›è¡Œå¯ç”¨æˆ–ç¦ç”¨ï¼Œä¸ä¼šå½±å“æ’ä»¶çš„æ ¸å¿ƒåŠŸèƒ½ã€‚ç”¨æˆ·å¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©æ˜¯å¦ä½¿ç”¨ NES åŠŸèƒ½ã€‚

### æ¨¡å—å±‚æ¬¡ç»“æ„

æ•´ä¸ªæ¶æ„åˆ†ä¸ºå››ä¸ªä¸»è¦å±‚æ¬¡ï¼Œæ¯ä¸ªå±‚æ¬¡éƒ½æœ‰æ˜ç¡®çš„èŒè´£å’ŒåŠŸèƒ½ï¼š

**è¡¨ç¤ºå±‚ (Presentation Layer)**: è´Ÿè´£ç”¨æˆ·ç•Œé¢çš„æ˜¾ç¤ºå’Œäº¤äº’å¤„ç†ã€‚åŒ…æ‹¬ NES å»ºè®®çš„å¯è§†åŒ–æ˜¾ç¤ºã€ç”¨æˆ·è¾“å…¥çš„å¤„ç†ã€é”®ç›˜æ˜ å°„çš„ç®¡ç†ç­‰ã€‚è¿™ä¸€å±‚ç›´æ¥ä¸ç”¨æˆ·è¿›è¡Œäº¤äº’ï¼Œæä¾›ç›´è§‚çš„ç”¨æˆ·ä½“éªŒã€‚

**ä¸šåŠ¡é€»è¾‘å±‚ (Business Logic Layer)**: åŒ…å« NES åŠŸèƒ½çš„æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼Œå¦‚å»ºè®®çš„ç”Ÿæˆã€è¿‡æ»¤ã€æ’åºã€çŠ¶æ€ç®¡ç†ç­‰ã€‚è¿™ä¸€å±‚å®ç°äº† NES åŠŸèƒ½çš„ä¸»è¦ç®—æ³•å’Œå¤„ç†é€»è¾‘ã€‚

**æœåŠ¡å±‚ (Service Layer)**: æä¾›ä¸ LSP æœåŠ¡å™¨é€šä¿¡çš„æœåŠ¡æ¥å£ï¼Œå¤„ç† LSP æ¶ˆæ¯çš„å‘é€å’Œæ¥æ”¶ã€‚è¿™ä¸€å±‚å°è£…äº†ä¸ GitHub Copilot Language Server çš„é€šä¿¡ç»†èŠ‚ã€‚

**æ•°æ®å±‚ (Data Layer)**: è´Ÿè´£æ•°æ®çš„å­˜å‚¨å’Œç®¡ç†ï¼ŒåŒ…æ‹¬å»ºè®®æ•°æ®çš„ç¼“å­˜ã€é…ç½®ä¿¡æ¯çš„å­˜å‚¨ç­‰ã€‚è¿™ä¸€å±‚æä¾›äº†æ•°æ®æŒä¹…åŒ–å’Œè®¿é—®çš„åŠŸèƒ½ã€‚

### æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### NES ç®¡ç†å™¨ (NES Manager)

NES ç®¡ç†å™¨æ˜¯æ•´ä¸ª NES åŠŸèƒ½çš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£åè°ƒå„ä¸ªå­æ¨¡å—çš„å·¥ä½œã€‚å®ƒé‡‡ç”¨å•ä¾‹æ¨¡å¼è®¾è®¡ï¼Œç¡®ä¿åœ¨æ•´ä¸ªæ’ä»¶ç”Ÿå‘½å‘¨æœŸä¸­åªæœ‰ä¸€ä¸ªç®¡ç†å™¨å®ä¾‹ã€‚

ç®¡ç†å™¨çš„ä¸»è¦èŒè´£åŒ…æ‹¬ï¼š

**ç”Ÿå‘½å‘¨æœŸç®¡ç†**: ç®¡ç† NES åŠŸèƒ½çš„åˆå§‹åŒ–ã€å¯åŠ¨ã€åœæ­¢å’Œæ¸…ç†è¿‡ç¨‹ã€‚ç¡®ä¿èµ„æºçš„æ­£ç¡®åˆ†é…å’Œé‡Šæ”¾ã€‚

**çŠ¶æ€åè°ƒ**: ç»´æŠ¤ NES åŠŸèƒ½çš„å…¨å±€çŠ¶æ€ï¼Œåè°ƒå„ä¸ªå­æ¨¡å—ä¹‹é—´çš„çŠ¶æ€åŒæ­¥ã€‚

**äº‹ä»¶åˆ†å‘**: æ¥æ”¶æ¥è‡ª LSP æœåŠ¡å™¨å’Œç”¨æˆ·ç•Œé¢çš„äº‹ä»¶ï¼Œå¹¶å°†å…¶åˆ†å‘ç»™ç›¸åº”çš„å¤„ç†æ¨¡å—ã€‚

**é…ç½®ç®¡ç†**: ç®¡ç† NES åŠŸèƒ½çš„é…ç½®ä¿¡æ¯ï¼Œæä¾›é…ç½®çš„è¯»å–ã€æ›´æ–°å’ŒéªŒè¯åŠŸèƒ½ã€‚

#### å»ºè®®å¤„ç†å™¨ (Suggestion Processor)

å»ºè®®å¤„ç†å™¨è´Ÿè´£å¤„ç†ä» LSP æœåŠ¡å™¨æ¥æ”¶åˆ°çš„ NES å»ºè®®æ•°æ®ã€‚å®ƒå®ç°äº†å»ºè®®çš„è§£æã€éªŒè¯ã€è¿‡æ»¤å’Œè½¬æ¢åŠŸèƒ½ã€‚

å¤„ç†å™¨çš„æ ¸å¿ƒåŠŸèƒ½åŒ…æ‹¬ï¼š

**æ•°æ®è§£æ**: å°†ä» LSP æœåŠ¡å™¨æ¥æ”¶åˆ°çš„åŸå§‹å»ºè®®æ•°æ®è§£æä¸ºå†…éƒ¨æ•°æ®ç»“æ„ã€‚

**å»ºè®®éªŒè¯**: éªŒè¯å»ºè®®æ•°æ®çš„å®Œæ•´æ€§å’Œæœ‰æ•ˆæ€§ï¼Œè¿‡æ»¤æ‰æ— æ•ˆæˆ–ä¸é€‚ç”¨çš„å»ºè®®ã€‚

**æ™ºèƒ½è¿‡æ»¤**: æ ¹æ®ç”¨æˆ·é…ç½®å’Œä¸Šä¸‹æ–‡ä¿¡æ¯å¯¹å»ºè®®è¿›è¡Œæ™ºèƒ½è¿‡æ»¤ï¼Œæé«˜å»ºè®®çš„ç›¸å…³æ€§ã€‚

**ä¼˜å…ˆçº§æ’åº**: æ ¹æ®å»ºè®®çš„ç½®ä¿¡åº¦ã€ç›¸å…³æ€§ç­‰å› ç´ å¯¹å»ºè®®è¿›è¡Œæ’åºï¼Œç¡®ä¿æœ€ç›¸å…³çš„å»ºè®®ä¼˜å…ˆæ˜¾ç¤ºã€‚

#### æ˜¾ç¤ºæ§åˆ¶å™¨ (Display Controller)

æ˜¾ç¤ºæ§åˆ¶å™¨è´Ÿè´£ç®¡ç† NES å»ºè®®çš„å¯è§†åŒ–æ˜¾ç¤ºã€‚å®ƒæ”¯æŒå¤šç§æ˜¾ç¤ºæ¨¡å¼ï¼ŒåŒ…æ‹¬æµ®åŠ¨çª—å£ã€å†…è”é«˜äº®ã€çŠ¶æ€æ æç¤ºç­‰ã€‚

æ§åˆ¶å™¨çš„ä¸»è¦åŠŸèƒ½åŒ…æ‹¬ï¼š

**å¤šæ¨¡å¼æ˜¾ç¤º**: æ”¯æŒæµ®åŠ¨çª—å£ã€å†…è”é«˜äº®ã€çŠ¶æ€æ ç­‰å¤šç§æ˜¾ç¤ºæ¨¡å¼ï¼Œç”¨æˆ·å¯ä»¥æ ¹æ®åå¥½è¿›è¡Œé€‰æ‹©ã€‚

**åŠ¨æ€æ›´æ–°**: å®æ—¶æ›´æ–°å»ºè®®çš„æ˜¾ç¤ºå†…å®¹ï¼Œå“åº”ç”¨æˆ·çš„æ“ä½œå’ŒçŠ¶æ€å˜åŒ–ã€‚

**æ ·å¼ç®¡ç†**: ç®¡ç†å»ºè®®æ˜¾ç¤ºçš„æ ·å¼å’Œä¸»é¢˜ï¼Œæ”¯æŒè‡ªå®šä¹‰é¢œè‰²ã€å­—ä½“ã€è¾¹æ¡†ç­‰è§†è§‰å…ƒç´ ã€‚

**äº¤äº’å¤„ç†**: å¤„ç†ç”¨æˆ·ä¸å»ºè®®æ˜¾ç¤ºç•Œé¢çš„äº¤äº’ï¼Œå¦‚ç‚¹å‡»ã€é”®ç›˜æ“ä½œç­‰ã€‚

### æ•°æ®æµè®¾è®¡

NES åŠŸèƒ½çš„æ•°æ®æµè®¾è®¡éµå¾ªå•å‘æ•°æ®æµåŸåˆ™ï¼Œç¡®ä¿æ•°æ®æµå‘çš„æ¸…æ™°æ€§å’Œå¯é¢„æµ‹æ€§ã€‚

#### å»ºè®®ç”Ÿæˆæµç¨‹

å»ºè®®ç”Ÿæˆçš„æ•°æ®æµç¨‹å¦‚ä¸‹ï¼š

1. **è§¦å‘äº‹ä»¶**: ç”¨æˆ·ç¼–è¾‘æ–‡æ¡£è§¦å‘ `textDocument/didChange` äº‹ä»¶
2. **äº‹ä»¶å¤„ç†**: NES ç®¡ç†å™¨æ¥æ”¶äº‹ä»¶å¹¶è¿›è¡Œé˜²æŠ–å¤„ç†
3. **è¯·æ±‚å‘é€**: å‘ LSP æœåŠ¡å™¨å‘é€å»ºè®®è¯·æ±‚
4. **å»ºè®®æ¥æ”¶**: æ¥æ”¶ `textDocument/publishNextEditSuggestions` é€šçŸ¥
5. **æ•°æ®å¤„ç†**: å»ºè®®å¤„ç†å™¨è§£æå’Œå¤„ç†å»ºè®®æ•°æ®
6. **æ˜¾ç¤ºæ›´æ–°**: æ˜¾ç¤ºæ§åˆ¶å™¨æ›´æ–°å»ºè®®çš„å¯è§†åŒ–æ˜¾ç¤º

#### ç”¨æˆ·äº¤äº’æµç¨‹

ç”¨æˆ·äº¤äº’çš„æ•°æ®æµç¨‹å¦‚ä¸‹ï¼š

1. **ç”¨æˆ·æ“ä½œ**: ç”¨æˆ·é€šè¿‡é”®ç›˜æˆ–é¼ æ ‡ä¸å»ºè®®è¿›è¡Œäº¤äº’
2. **äº‹ä»¶æ•è·**: æ˜¾ç¤ºæ§åˆ¶å™¨æ•è·ç”¨æˆ·æ“ä½œäº‹ä»¶
3. **å‘½ä»¤ç”Ÿæˆ**: æ ¹æ®ç”¨æˆ·æ“ä½œç”Ÿæˆç›¸åº”çš„ LSP å‘½ä»¤
4. **å‘½ä»¤å‘é€**: å‘ LSP æœåŠ¡å™¨å‘é€å‘½ä»¤ï¼ˆå¦‚æ¥å—æˆ–æ‹’ç»å»ºè®®ï¼‰
5. **çŠ¶æ€æ›´æ–°**: æ›´æ–°å»ºè®®çš„çŠ¶æ€å’Œæ˜¾ç¤º
6. **åé¦ˆå¤„ç†**: å¤„ç† LSP æœåŠ¡å™¨çš„å“åº”å’Œåé¦ˆ

### é”™è¯¯å¤„ç†ç­–ç•¥

NES åŠŸèƒ½é‡‡ç”¨å¤šå±‚æ¬¡çš„é”™è¯¯å¤„ç†ç­–ç•¥ï¼Œç¡®ä¿ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œå¯é æ€§ï¼š

**ä¼˜é›…é™çº§**: å½“ NES åŠŸèƒ½å‡ºç°é”™è¯¯æ—¶ï¼Œç³»ç»Ÿä¼šä¼˜é›…åœ°é™çº§åˆ°åŸºæœ¬åŠŸèƒ½ï¼Œä¸å½±å“ç”¨æˆ·çš„æ­£å¸¸ç¼–ç¨‹å·¥ä½œã€‚

**é”™è¯¯éš”ç¦»**: é”™è¯¯è¢«é™åˆ¶åœ¨ç‰¹å®šçš„æ¨¡å—å†…ï¼Œä¸ä¼šä¼ æ’­åˆ°å…¶ä»–åŠŸèƒ½æ¨¡å—ã€‚

**è‡ªåŠ¨æ¢å¤**: ç³»ç»Ÿå…·å¤‡è‡ªåŠ¨é”™è¯¯æ¢å¤èƒ½åŠ›ï¼Œèƒ½å¤Ÿåœ¨é”™è¯¯æ¡ä»¶æ¶ˆé™¤åè‡ªåŠ¨æ¢å¤æ­£å¸¸åŠŸèƒ½ã€‚

**è¯¦ç»†æ—¥å¿—**: æä¾›è¯¦ç»†çš„é”™è¯¯æ—¥å¿—å’Œè¯Šæ–­ä¿¡æ¯ï¼Œä¾¿äºé—®é¢˜çš„å®šä½å’Œè§£å†³ã€‚

## æ ¸å¿ƒæ¨¡å—å®ç°

### NES ä¸»æ¨¡å—å®ç°

NES ä¸»æ¨¡å—æ˜¯æ•´ä¸ªåŠŸèƒ½çš„å…¥å£ç‚¹å’Œåè°ƒä¸­å¿ƒã€‚å®ƒè´Ÿè´£åˆå§‹åŒ–å„ä¸ªå­æ¨¡å—ï¼Œç®¡ç†æ¨¡å—é—´çš„é€šä¿¡ï¼Œå¹¶æä¾›ç»Ÿä¸€çš„å¤–éƒ¨æ¥å£ã€‚

#### æ¨¡å—ç»“æ„è®¾è®¡

```lua
-- lua/copilot/nes/init.lua
local api = require("copilot.api")
local config = require("copilot.config")
local logger = require("copilot.logger")
local util = require("copilot.util")

local manager = require("copilot.nes.manager")
local display = require("copilot.nes.display")
local handlers = require("copilot.nes.handlers")

local M = {}

-- æ¨¡å—çŠ¶æ€
local state = {
  initialized = false,
  enabled = false,
  client_id = nil,
  current_buffer = nil,
  suggestions = {},
  active_suggestion = nil
}

-- æ¨¡å—é…ç½®
local default_config = {
  enabled = true,
  auto_trigger = true,
  debounce = 500,
  max_suggestions = 5,
  display = {
    type = "float",
    auto_show = true,
    timeout = 5000
  },
  keymaps = {
    accept = "<C-y>",
    reject = "<C-n>",
    next = "<C-]>",
    prev = "<C-[>",
    toggle = "<leader>cn"
  },
  filter = {
    min_confidence = 0.5,
    exclude_filetypes = { "help", "alpha", "dashboard" }
  }
}
```

#### åˆå§‹åŒ–å‡½æ•°å®ç°

åˆå§‹åŒ–å‡½æ•°è´Ÿè´£è®¾ç½® NES åŠŸèƒ½çš„åŸºç¡€ç¯å¢ƒï¼ŒåŒ…æ‹¬é…ç½®åŠ è½½ã€äº‹ä»¶ç›‘å¬å™¨æ³¨å†Œã€é”®ç›˜æ˜ å°„è®¾ç½®ç­‰ï¼š

```lua
-- åˆå§‹åŒ– NES åŠŸèƒ½
function M.setup(opts)
  if state.initialized then
    logger.warn("NES module already initialized")
    return
  end
  
  -- åˆå¹¶ç”¨æˆ·é…ç½®
  local nes_config = vim.tbl_deep_extend("force", default_config, opts or {})
  
  -- éªŒè¯é…ç½®
  if not M._validate_config(nes_config) then
    logger.error("Invalid NES configuration")
    return false
  end
  
  -- å­˜å‚¨é…ç½®
  state.config = nes_config
  
  -- åˆå§‹åŒ–å­æ¨¡å—
  manager.setup(nes_config)
  display.setup(nes_config.display)
  handlers.setup(nes_config)
  
  -- æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
  M._register_autocmds()
  
  -- è®¾ç½®é”®ç›˜æ˜ å°„
  M._setup_keymaps(nes_config.keymaps)
  
  -- æ ‡è®°ä¸ºå·²åˆå§‹åŒ–
  state.initialized = true
  state.enabled = nes_config.enabled
  
  logger.info("NES module initialized successfully")
  return true
end

-- é…ç½®éªŒè¯å‡½æ•°
function M._validate_config(config)
  -- éªŒè¯å¿…éœ€å­—æ®µ
  if type(config.enabled) ~= "boolean" then
    logger.error("config.enabled must be boolean")
    return false
  end
  
  if type(config.debounce) ~= "number" or config.debounce < 0 then
    logger.error("config.debounce must be non-negative number")
    return false
  end
  
  if type(config.max_suggestions) ~= "number" or config.max_suggestions < 1 then
    logger.error("config.max_suggestions must be positive number")
    return false
  end
  
  -- éªŒè¯æ˜¾ç¤ºé…ç½®
  if config.display then
    local valid_types = { "float", "inline", "both" }
    if not vim.tbl_contains(valid_types, config.display.type) then
      logger.error("config.display.type must be one of: " .. table.concat(valid_types, ", "))
      return false
    end
  end
  
  return true
end
```

#### äº‹ä»¶ç›‘å¬å™¨æ³¨å†Œ

äº‹ä»¶ç›‘å¬å™¨è´Ÿè´£å“åº”æ–‡æ¡£å˜åŒ–ã€å…‰æ ‡ç§»åŠ¨ç­‰äº‹ä»¶ï¼Œè§¦å‘ç›¸åº”çš„ NES å¤„ç†é€»è¾‘ï¼š

```lua
-- æ³¨å†Œè‡ªåŠ¨å‘½ä»¤
function M._register_autocmds()
  local augroup = vim.api.nvim_create_augroup("CopilotNES", { clear = true })
  
  -- æ–‡æ¡£å˜åŒ–äº‹ä»¶
  vim.api.nvim_create_autocmd({ "TextChanged", "TextChangedI" }, {
    group = augroup,
    callback = function(args)
      if not state.enabled then return end
      
      local bufnr = args.buf
      if M._should_process_buffer(bufnr) then
        M._on_text_changed(bufnr)
      end
    end,
    desc = "Trigger NES on text change"
  })
  
  -- å…‰æ ‡ç§»åŠ¨äº‹ä»¶
  vim.api.nvim_create_autocmd({ "CursorMoved", "CursorMovedI" }, {
    group = augroup,
    callback = function(args)
      if not state.enabled then return end
      
      local bufnr = args.buf
      if M._should_process_buffer(bufnr) then
        M._on_cursor_moved(bufnr)
      end
    end,
    desc = "Update NES on cursor move"
  })
  
  -- ç¼“å†²åŒºç¦»å¼€äº‹ä»¶
  vim.api.nvim_create_autocmd("BufLeave", {
    group = augroup,
    callback = function(args)
      local bufnr = args.buf
      M._on_buf_leave(bufnr)
    end,
    desc = "Clean up NES on buffer leave"
  })
  
  -- LSP å®¢æˆ·ç«¯é™„åŠ äº‹ä»¶
  vim.api.nvim_create_autocmd("LspAttach", {
    group = augroup,
    callback = function(args)
      local client = vim.lsp.get_client_by_id(args.data.client_id)
      if client and client.name == "copilot" then
        M._on_lsp_attach(client, args.buf)
      end
    end,
    desc = "Setup NES on LSP attach"
  })
end

-- æ£€æŸ¥æ˜¯å¦åº”è¯¥å¤„ç†è¯¥ç¼“å†²åŒº
function M._should_process_buffer(bufnr)
  -- æ£€æŸ¥æ–‡ä»¶ç±»å‹
  local filetype = vim.api.nvim_buf_get_option(bufnr, "filetype")
  if vim.tbl_contains(state.config.filter.exclude_filetypes, filetype) then
    return false
  end
  
  -- æ£€æŸ¥ç¼“å†²åŒºç±»å‹
  local buftype = vim.api.nvim_buf_get_option(bufnr, "buftype")
  if buftype ~= "" then
    return false
  end
  
  -- æ£€æŸ¥æ˜¯å¦ä¸ºå¯ä¿®æ”¹ç¼“å†²åŒº
  if not vim.api.nvim_buf_get_option(bufnr, "modifiable") then
    return false
  end
  
  return true
end
```

#### æ ¸å¿ƒäº‹ä»¶å¤„ç†å‡½æ•°

è¿™äº›å‡½æ•°å¤„ç†å„ç§äº‹ä»¶ï¼Œåè°ƒ NES åŠŸèƒ½çš„è¿è¡Œï¼š

```lua
-- å¤„ç†æ–‡æ¡£å˜åŒ–äº‹ä»¶
function M._on_text_changed(bufnr)
  -- é˜²æŠ–å¤„ç†
  if state.debounce_timer then
    vim.fn.timer_stop(state.debounce_timer)
  end
  
  state.debounce_timer = vim.fn.timer_start(state.config.debounce, function()
    M._request_suggestions(bufnr)
  end)
end

-- å¤„ç†å…‰æ ‡ç§»åŠ¨äº‹ä»¶
function M._on_cursor_moved(bufnr)
  -- æ›´æ–°å½“å‰å»ºè®®çš„æ˜¾ç¤º
  display.update_cursor_position(bufnr)
  
  -- æ£€æŸ¥æ˜¯å¦éœ€è¦éšè—å»ºè®®
  local cursor_pos = vim.api.nvim_win_get_cursor(0)
  if state.active_suggestion then
    local suggestion_range = state.active_suggestion.range
    if not M._cursor_in_range(cursor_pos, suggestion_range) then
      M.hide_current_suggestion()
    end
  end
end

-- å¤„ç†ç¼“å†²åŒºç¦»å¼€äº‹ä»¶
function M._on_buf_leave(bufnr)
  -- æ¸…ç†è¯¥ç¼“å†²åŒºçš„å»ºè®®
  M.clear_suggestions(bufnr)
  
  -- éšè—æ˜¾ç¤º
  if state.current_buffer == bufnr then
    display.hide_all()
    state.current_buffer = nil
  end
end

-- å¤„ç† LSP å®¢æˆ·ç«¯é™„åŠ äº‹ä»¶
function M._on_lsp_attach(client, bufnr)
  state.client_id = client.id
  logger.info("NES attached to LSP client: " .. client.name)
  
  -- æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦æ”¯æŒ NES
  if M._check_nes_support(client) then
    logger.info("NES support detected")
  else
    logger.warn("NES not supported by server")
  end
end

-- æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦æ”¯æŒ NES
function M._check_nes_support(client)
  -- æ£€æŸ¥æœåŠ¡å™¨èƒ½åŠ›
  local capabilities = client.server_capabilities
  if not capabilities then
    return false
  end
  
  -- æ£€æŸ¥æ˜¯å¦æ”¯æŒè‡ªå®šä¹‰å‘½ä»¤
  if capabilities.executeCommandProvider then
    local commands = capabilities.executeCommandProvider.commands or {}
    for _, command in ipairs(commands) do
      if command == "github.copilot.didAcceptNextEditSuggestionItem" then
        return true
      end
    end
  end
  
  return false
end
```


### å»ºè®®ç®¡ç†å™¨å®ç°

å»ºè®®ç®¡ç†å™¨æ˜¯ NES åŠŸèƒ½çš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£ç®¡ç†å»ºè®®çš„ç”Ÿå‘½å‘¨æœŸã€çŠ¶æ€è·Ÿè¸ªå’Œæ•°æ®å¤„ç†ã€‚å®ƒé‡‡ç”¨é«˜æ•ˆçš„æ•°æ®ç»“æ„å’Œç®—æ³•æ¥ç¡®ä¿å»ºè®®å¤„ç†çš„æ€§èƒ½å’Œå‡†ç¡®æ€§ã€‚

#### ç®¡ç†å™¨æ•°æ®ç»“æ„

```lua
-- lua/copilot/nes/manager.lua
local logger = require("copilot.logger")
local util = require("copilot.util")

local M = {}

-- å»ºè®®æ•°æ®ç»“æ„
local Suggestion = {}
Suggestion.__index = Suggestion

function Suggestion:new(data)
  local obj = {
    id = data.id or util.generate_id(),
    type = "next_edit_suggestion",
    range = data.range,
    new_text = data.new_text,
    description = data.description or "",
    confidence = data.confidence or 0.5,
    created_at = os.time(),
    status = "pending", -- pending, accepted, rejected, expired
    metadata = data.metadata or {}
  }
  setmetatable(obj, self)
  return obj
end

function Suggestion:is_valid()
  return self.range and self.new_text and self.status == "pending"
end

function Suggestion:is_expired(timeout)
  return (os.time() - self.created_at) > (timeout or 5)
end

function Suggestion:accept()
  self.status = "accepted"
  self.accepted_at = os.time()
end

function Suggestion:reject()
  self.status = "rejected"
  self.rejected_at = os.time()
end

-- ç®¡ç†å™¨çŠ¶æ€
local manager_state = {
  suggestions = {}, -- æŒ‰ç¼“å†²åŒº ID ç»„ç»‡çš„å»ºè®®
  active_suggestions = {}, -- å½“å‰æ´»è·ƒçš„å»ºè®®
  config = {},
  stats = {
    total_suggestions = 0,
    accepted_suggestions = 0,
    rejected_suggestions = 0
  }
}
```

#### å»ºè®®å¤„ç†æ ¸å¿ƒé€»è¾‘

```lua
-- åˆå§‹åŒ–ç®¡ç†å™¨
function M.setup(config)
  manager_state.config = config
  logger.info("NES manager initialized")
end

-- æ·»åŠ æ–°å»ºè®®
function M.add_suggestions(bufnr, suggestions_data)
  if not suggestions_data or #suggestions_data == 0 then
    return
  end
  
  -- åˆå§‹åŒ–ç¼“å†²åŒºå»ºè®®åˆ—è¡¨
  if not manager_state.suggestions[bufnr] then
    manager_state.suggestions[bufnr] = {}
  end
  
  local buffer_suggestions = manager_state.suggestions[bufnr]
  local new_suggestions = {}
  
  for _, data in ipairs(suggestions_data) do
    -- åˆ›å»ºå»ºè®®å¯¹è±¡
    local suggestion = Suggestion:new(data)
    
    -- éªŒè¯å»ºè®®
    if suggestion:is_valid() and M._should_accept_suggestion(suggestion) then
      table.insert(buffer_suggestions, suggestion)
      table.insert(new_suggestions, suggestion)
      manager_state.stats.total_suggestions = manager_state.stats.total_suggestions + 1
    end
  end
  
  -- æ¸…ç†è¿‡æœŸå»ºè®®
  M._cleanup_expired_suggestions(bufnr)
  
  -- æ’åºå»ºè®®
  M._sort_suggestions(bufnr)
  
  -- é™åˆ¶å»ºè®®æ•°é‡
  M._limit_suggestions(bufnr)
  
  logger.info(string.format("Added %d new suggestions for buffer %d", #new_suggestions, bufnr))
  return new_suggestions
end

-- æ£€æŸ¥æ˜¯å¦åº”è¯¥æ¥å—å»ºè®®
function M._should_accept_suggestion(suggestion)
  -- æ£€æŸ¥ç½®ä¿¡åº¦
  if suggestion.confidence < manager_state.config.filter.min_confidence then
    return false
  end
  
  -- æ£€æŸ¥æ–‡æœ¬é•¿åº¦
  if #suggestion.new_text > 1000 then -- é™åˆ¶å»ºè®®æ–‡æœ¬é•¿åº¦
    return false
  end
  
  -- æ£€æŸ¥èŒƒå›´æœ‰æ•ˆæ€§
  if not M._is_valid_range(suggestion.range) then
    return false
  end
  
  return true
end

-- éªŒè¯èŒƒå›´æœ‰æ•ˆæ€§
function M._is_valid_range(range)
  if not range or not range.start or not range["end"] then
    return false
  end
  
  local start_line = range.start.line
  local start_char = range.start.character
  local end_line = range["end"].line
  local end_char = range["end"].character
  
  -- æ£€æŸ¥è¡Œå·å’Œå­—ç¬¦ä½ç½®çš„æœ‰æ•ˆæ€§
  if start_line < 0 or end_line < 0 or start_char < 0 or end_char < 0 then
    return false
  end
  
  -- æ£€æŸ¥èŒƒå›´é¡ºåº
  if start_line > end_line or (start_line == end_line and start_char > end_char) then
    return false
  end
  
  return true
end

-- æ’åºå»ºè®®
function M._sort_suggestions(bufnr)
  local suggestions = manager_state.suggestions[bufnr]
  if not suggestions then return end
  
  table.sort(suggestions, function(a, b)
    -- æŒ‰ç½®ä¿¡åº¦é™åºæ’åˆ—
    if a.confidence ~= b.confidence then
      return a.confidence > b.confidence
    end
    
    -- æŒ‰åˆ›å»ºæ—¶é—´å‡åºæ’åˆ—
    return a.created_at < b.created_at
  end)
end

-- é™åˆ¶å»ºè®®æ•°é‡
function M._limit_suggestions(bufnr)
  local suggestions = manager_state.suggestions[bufnr]
  if not suggestions then return end
  
  local max_suggestions = manager_state.config.max_suggestions
  if #suggestions > max_suggestions then
    -- ç§»é™¤å¤šä½™çš„å»ºè®®
    for i = max_suggestions + 1, #suggestions do
      suggestions[i] = nil
    end
  end
end

-- æ¸…ç†è¿‡æœŸå»ºè®®
function M._cleanup_expired_suggestions(bufnr)
  local suggestions = manager_state.suggestions[bufnr]
  if not suggestions then return end
  
  local timeout = manager_state.config.display.timeout / 1000 -- è½¬æ¢ä¸ºç§’
  local valid_suggestions = {}
  
  for _, suggestion in ipairs(suggestions) do
    if not suggestion:is_expired(timeout) and suggestion.status == "pending" then
      table.insert(valid_suggestions, suggestion)
    end
  end
  
  manager_state.suggestions[bufnr] = valid_suggestions
end

-- è·å–ç¼“å†²åŒºçš„å»ºè®®
function M.get_suggestions(bufnr)
  return manager_state.suggestions[bufnr] or {}
end

-- è·å–æœ€ä½³å»ºè®®
function M.get_best_suggestion(bufnr)
  local suggestions = M.get_suggestions(bufnr)
  if #suggestions > 0 then
    return suggestions[1] -- å·²æ’åºï¼Œç¬¬ä¸€ä¸ªæ˜¯æœ€ä½³çš„
  end
  return nil
end

-- æ¥å—å»ºè®®
function M.accept_suggestion(suggestion_id, bufnr)
  local suggestions = manager_state.suggestions[bufnr]
  if not suggestions then return false end
  
  for _, suggestion in ipairs(suggestions) do
    if suggestion.id == suggestion_id then
      suggestion:accept()
      manager_state.stats.accepted_suggestions = manager_state.stats.accepted_suggestions + 1
      logger.info("Suggestion accepted: " .. suggestion_id)
      return true
    end
  end
  
  return false
end

-- æ‹’ç»å»ºè®®
function M.reject_suggestion(suggestion_id, bufnr)
  local suggestions = manager_state.suggestions[bufnr]
  if not suggestions then return false end
  
  for _, suggestion in ipairs(suggestions) do
    if suggestion.id == suggestion_id then
      suggestion:reject()
      manager_state.stats.rejected_suggestions = manager_state.stats.rejected_suggestions + 1
      logger.info("Suggestion rejected: " .. suggestion_id)
      return true
    end
  end
  
  return false
end

-- æ¸…ç†ç¼“å†²åŒºå»ºè®®
function M.clear_suggestions(bufnr)
  if manager_state.suggestions[bufnr] then
    manager_state.suggestions[bufnr] = {}
    logger.info("Cleared suggestions for buffer: " .. bufnr)
  end
end

-- è·å–ç»Ÿè®¡ä¿¡æ¯
function M.get_stats()
  return vim.deepcopy(manager_state.stats)
end

return M
```

## LSP é›†æˆæ‰©å±•

LSP é›†æˆæ‰©å±•æ˜¯ NES åŠŸèƒ½ä¸ GitHub Copilot Language Server é€šä¿¡çš„æ¡¥æ¢ã€‚å®ƒè´Ÿè´£å¤„ç† LSP åè®®çš„æ‰©å±•æ¶ˆæ¯ï¼Œç®¡ç†ä¸æœåŠ¡å™¨çš„é€šä¿¡ï¼Œå¹¶ç¡®ä¿æ¶ˆæ¯çš„æ­£ç¡®è·¯ç”±å’Œå¤„ç†ã€‚

### LSP å¤„ç†å™¨æ‰©å±•

åœ¨ç°æœ‰çš„ `lua/copilot/lsp/init.lua` æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ å¯¹ NES ç›¸å…³ LSP æ¶ˆæ¯çš„å¤„ç†æ”¯æŒï¼š

```lua
-- åœ¨ lua/copilot/lsp/init.lua ä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹

local nes = require("copilot.nes")
local logger = require("copilot.logger")

-- NES ç›¸å…³çš„ LSP å¤„ç†å™¨
local nes_handlers = {
  -- å¤„ç† Next Edit Suggestions é€šçŸ¥
  ["textDocument/publishNextEditSuggestions"] = function(err, result, ctx, config)
    if err then
      logger.error("Error in publishNextEditSuggestions: " .. vim.inspect(err))
      return
    end
    
    if not result or not result.suggestions then
      logger.debug("No suggestions received")
      return
    end
    
    local bufnr = ctx.bufnr
    local client_id = ctx.client_id
    
    logger.debug(string.format("Received %d NES suggestions for buffer %d", 
                              #result.suggestions, bufnr))
    
    -- å¤„ç†å»ºè®®
    nes.handle_suggestions(result.suggestions, bufnr, client_id)
  end,
  
  -- å¤„ç†æ¥å—å»ºè®®çš„å“åº”
  ["github.copilot.didAcceptNextEditSuggestionItem"] = function(err, result, ctx, config)
    if err then
      logger.error("Error in didAcceptNextEditSuggestionItem: " .. vim.inspect(err))
      return
    end
    
    logger.debug("Accept suggestion response received")
    nes.handle_accept_response(result, ctx.client_id)
  end,
  
  -- å¤„ç†æ‹’ç»å»ºè®®çš„å“åº”
  ["github.copilot.didRejectNextEditSuggestionItem"] = function(err, result, ctx, config)
    if err then
      logger.error("Error in didRejectNextEditSuggestionItem: " .. vim.inspect(err))
      return
    end
    
    logger.debug("Reject suggestion response received")
    nes.handle_reject_response(result, ctx.client_id)
  end
}

-- æ‰©å±•ç°æœ‰çš„ setup å‡½æ•°
local original_setup = M.setup
function M.setup(server_config, copilot_node_command)
  -- è°ƒç”¨åŸå§‹ setup å‡½æ•°
  local result = original_setup(server_config, copilot_node_command)
  
  -- æ·»åŠ  NES å¤„ç†å™¨
  if server_config.handlers then
    server_config.handlers = vim.tbl_extend("force", server_config.handlers, nes_handlers)
  else
    server_config.handlers = nes_handlers
  end
  
  logger.info("NES LSP handlers registered")
  return result
end

-- æ‰©å±•å‘½ä»¤æ‰§è¡Œå™¨
local original_get_execute_command = M.get_execute_command
function M.get_execute_command()
  local commands = original_get_execute_command()
  
  -- æ·»åŠ  NES ç›¸å…³å‘½ä»¤
  local nes_commands = {
    "github.copilot.didAcceptNextEditSuggestionItem",
    "github.copilot.didRejectNextEditSuggestionItem",
  }
  
  for _, command in ipairs(nes_commands) do
    table.insert(commands, command)
  end
  
  return commands
end
```

### LSP æ¶ˆæ¯å‘é€æ¥å£

ä¸ºäº†ä¸ LSP æœåŠ¡å™¨è¿›è¡Œé€šä¿¡ï¼Œæˆ‘ä»¬éœ€è¦å®ç°å‘é€ NES ç›¸å…³æ¶ˆæ¯çš„æ¥å£ï¼š

```lua
-- åœ¨ lua/copilot/nes/lsp_client.lua ä¸­å®ç°

local M = {}

-- è¯·æ±‚ Next Edit Suggestions
function M.request_suggestions(bufnr, client_id)
  local client = vim.lsp.get_client_by_id(client_id)
  if not client then
    logger.error("LSP client not found: " .. client_id)
    return false
  end
  
  -- è·å–æ–‡æ¡£ä¿¡æ¯
  local uri = vim.uri_from_bufnr(bufnr)
  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
  local text = table.concat(lines, "\n")
  
  -- è·å–å…‰æ ‡ä½ç½®
  local cursor = vim.api.nvim_win_get_cursor(0)
  local position = {
    line = cursor[1] - 1, -- LSP ä½¿ç”¨ 0 åŸºç´¢å¼•
    character = cursor[2]
  }
  
  -- æ„å»ºè¯·æ±‚å‚æ•°
  local params = {
    textDocument = {
      uri = uri,
      version = vim.lsp.util.buf_versions[bufnr] or 0
    },
    position = position,
    context = {
      triggerKind = 1, -- æ‰‹åŠ¨è§¦å‘
      triggerCharacter = nil
    }
  }
  
  -- å‘é€è¯·æ±‚ï¼ˆæ³¨æ„ï¼šè¿™æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰æ–¹æ³•ï¼Œå¯èƒ½éœ€è¦æ ¹æ®å®é™… LSP æœåŠ¡å™¨å®ç°è°ƒæ•´ï¼‰
  client.request("textDocument/nextEditSuggestions", params, function(err, result)
    if err then
      logger.error("Error requesting NES: " .. vim.inspect(err))
      return
    end
    
    if result and result.suggestions then
      require("copilot.nes").handle_suggestions(result.suggestions, bufnr, client_id)
    end
  end, bufnr)
  
  return true
end

-- å‘é€æ¥å—å»ºè®®å‘½ä»¤
function M.accept_suggestion(suggestion_id, bufnr, client_id)
  local client = vim.lsp.get_client_by_id(client_id)
  if not client then
    logger.error("LSP client not found: " .. client_id)
    return false
  end
  
  local params = {
    arguments = {
      suggestionId = suggestion_id,
      bufnr = bufnr
    }
  }
  
  client.request("workspace/executeCommand", {
    command = "github.copilot.didAcceptNextEditSuggestionItem",
    arguments = { params }
  }, function(err, result)
    if err then
      logger.error("Error accepting suggestion: " .. vim.inspect(err))
    else
      logger.debug("Suggestion accepted successfully")
    end
  end, bufnr)
  
  return true
end

-- å‘é€æ‹’ç»å»ºè®®å‘½ä»¤
function M.reject_suggestion(suggestion_id, bufnr, client_id)
  local client = vim.lsp.get_client_by_id(client_id)
  if not client then
    logger.error("LSP client not found: " .. client_id)
    return false
  end
  
  local params = {
    arguments = {
      suggestionId = suggestion_id,
      bufnr = bufnr
    }
  }
  
  client.request("workspace/executeCommand", {
    command = "github.copilot.didRejectNextEditSuggestionItem", 
    arguments = { params }
  }, function(err, result)
    if err then
      logger.error("Error rejecting suggestion: " .. vim.inspect(err))
    else
      logger.debug("Suggestion rejected successfully")
    end
  end, bufnr)
  
  return true
end

-- å‘é€æ–‡æ¡£å˜åŒ–é€šçŸ¥
function M.notify_text_changed(bufnr, client_id, changes)
  local client = vim.lsp.get_client_by_id(client_id)
  if not client then
    return false
  end
  
  local uri = vim.uri_from_bufnr(bufnr)
  local version = vim.lsp.util.buf_versions[bufnr] or 0
  
  local params = {
    textDocument = {
      uri = uri,
      version = version
    },
    contentChanges = changes
  }
  
  client.notify("textDocument/didChange", params)
  return true
end

return M
```

### åè®®é€‚é…å±‚

ä¸ºäº†å¤„ç†ä¸åŒç‰ˆæœ¬çš„ LSP æœåŠ¡å™¨å’Œåè®®å˜åŒ–ï¼Œæˆ‘ä»¬å®ç°ä¸€ä¸ªåè®®é€‚é…å±‚ï¼š

```lua
-- lua/copilot/nes/protocol_adapter.lua

local M = {}

-- åè®®ç‰ˆæœ¬æ£€æµ‹
function M.detect_protocol_version(client)
  local capabilities = client.server_capabilities
  if not capabilities then
    return "unknown"
  end
  
  -- æ£€æŸ¥æ˜¯å¦æ”¯æŒ NES ç›¸å…³èƒ½åŠ›
  if capabilities.nextEditSuggestionsProvider then
    return "v2" -- å‡è®¾çš„æ–°ç‰ˆæœ¬åè®®
  elseif capabilities.executeCommandProvider then
    local commands = capabilities.executeCommandProvider.commands or {}
    for _, command in ipairs(commands) do
      if command:match("nextEditSuggestion") then
        return "v1" -- å½“å‰ç‰ˆæœ¬åè®®
      end
    end
  end
  
  return "unsupported"
end

-- é€‚é…å»ºè®®æ•°æ®æ ¼å¼
function M.adapt_suggestions(suggestions, protocol_version)
  if protocol_version == "v1" then
    return M._adapt_v1_suggestions(suggestions)
  elseif protocol_version == "v2" then
    return M._adapt_v2_suggestions(suggestions)
  else
    logger.warn("Unsupported protocol version: " .. protocol_version)
    return {}
  end
end

-- é€‚é… v1 åè®®å»ºè®®æ ¼å¼
function M._adapt_v1_suggestions(suggestions)
  local adapted = {}
  
  for _, suggestion in ipairs(suggestions) do
    table.insert(adapted, {
      id = suggestion.id or util.generate_id(),
      range = suggestion.range,
      new_text = suggestion.newText or suggestion.text,
      description = suggestion.description or "",
      confidence = suggestion.confidence or 0.5,
      metadata = suggestion.metadata or {}
    })
  end
  
  return adapted
end

-- é€‚é… v2 åè®®å»ºè®®æ ¼å¼ï¼ˆå‡è®¾çš„æœªæ¥ç‰ˆæœ¬ï¼‰
function M._adapt_v2_suggestions(suggestions)
  local adapted = {}
  
  for _, suggestion in ipairs(suggestions) do
    table.insert(adapted, {
      id = suggestion.suggestionId,
      range = {
        start = suggestion.range.start,
        ["end"] = suggestion.range["end"]
      },
      new_text = suggestion.replacementText,
      description = suggestion.title or "",
      confidence = suggestion.score or 0.5,
      metadata = {
        category = suggestion.category,
        reasoning = suggestion.reasoning
      }
    })
  end
  
  return adapted
end

-- é€‚é…å‘½ä»¤å‚æ•°æ ¼å¼
function M.adapt_command_params(command, params, protocol_version)
  if protocol_version == "v1" then
    return M._adapt_v1_command_params(command, params)
  elseif protocol_version == "v2" then
    return M._adapt_v2_command_params(command, params)
  else
    return params
  end
end

function M._adapt_v1_command_params(command, params)
  -- v1 åè®®çš„å‚æ•°æ ¼å¼é€‚é…
  return params
end

function M._adapt_v2_command_params(command, params)
  -- v2 åè®®çš„å‚æ•°æ ¼å¼é€‚é…
  return params
end

return M
```


## ç”¨æˆ·ç•Œé¢å®ç°

ç”¨æˆ·ç•Œé¢æ˜¯ NES åŠŸèƒ½ä¸ç”¨æˆ·äº¤äº’çš„é‡è¦ç»„ä»¶ã€‚å®ƒè´Ÿè´£ä»¥ç›´è§‚ã€ç¾è§‚çš„æ–¹å¼å±•ç¤ºå»ºè®®ï¼Œå¹¶æä¾›ä¾¿æ·çš„äº¤äº’æ–¹å¼è®©ç”¨æˆ·æ¥å—æˆ–æ‹’ç»å»ºè®®ã€‚æˆ‘ä»¬çš„è®¾è®¡æ”¯æŒå¤šç§æ˜¾ç¤ºæ¨¡å¼ï¼Œä»¥é€‚åº”ä¸åŒç”¨æˆ·çš„åå¥½å’Œä½¿ç”¨åœºæ™¯ã€‚

### æ˜¾ç¤ºæ§åˆ¶å™¨å®ç°

æ˜¾ç¤ºæ§åˆ¶å™¨æ˜¯ç”¨æˆ·ç•Œé¢çš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£ç®¡ç†æ‰€æœ‰çš„æ˜¾ç¤ºé€»è¾‘å’Œç”¨æˆ·äº¤äº’ï¼š

```lua
-- lua/copilot/nes/display.lua
local api = vim.api
local fn = vim.fn

local M = {}

-- æ˜¾ç¤ºçŠ¶æ€
local display_state = {
  config = {},
  active_windows = {}, -- æ´»è·ƒçš„æµ®åŠ¨çª—å£
  active_highlights = {}, -- æ´»è·ƒçš„é«˜äº®
  namespace_id = nil, -- å‘½åç©ºé—´ ID
  current_suggestion = nil -- å½“å‰æ˜¾ç¤ºçš„å»ºè®®
}

-- é«˜äº®ç»„å®šä¹‰
local highlight_groups = {
  CopilotNESRange = { bg = "#3e4451", fg = "#abb2bf" },
  CopilotNESText = { bg = "#2c313c", fg = "#98c379" },
  CopilotNESBorder = { fg = "#61afef" },
  CopilotNESTitle = { fg = "#e06c75", bold = true },
  CopilotNESDescription = { fg = "#56b6c2", italic = true },
  CopilotNESConfidence = { fg = "#d19a66" }
}

-- åˆå§‹åŒ–æ˜¾ç¤ºæ§åˆ¶å™¨
function M.setup(config)
  display_state.config = config
  display_state.namespace_id = api.nvim_create_namespace("copilot_nes")
  
  -- åˆ›å»ºé«˜äº®ç»„
  M._create_highlight_groups()
  
  logger.info("NES display controller initialized")
end

-- åˆ›å»ºé«˜äº®ç»„
function M._create_highlight_groups()
  for group_name, attrs in pairs(highlight_groups) do
    local cmd = "highlight default " .. group_name
    for attr, value in pairs(attrs) do
      if attr == "fg" then
        cmd = cmd .. " guifg=" .. value
      elseif attr == "bg" then
        cmd = cmd .. " guibg=" .. value
      elseif attr == "bold" then
        cmd = cmd .. " gui=bold"
      elseif attr == "italic" then
        cmd = cmd .. " gui=italic"
      end
    end
    vim.cmd(cmd)
  end
end

-- æ˜¾ç¤ºå»ºè®®
function M.show_suggestion(suggestion, bufnr)
  if not suggestion or not suggestion:is_valid() then
    return false
  end
  
  -- éšè—ä¹‹å‰çš„å»ºè®®
  M.hide_current_suggestion()
  
  display_state.current_suggestion = suggestion
  
  -- æ ¹æ®é…ç½®é€‰æ‹©æ˜¾ç¤ºæ¨¡å¼
  local display_type = display_state.config.type
  
  if display_type == "float" then
    M._show_float_window(suggestion, bufnr)
  elseif display_type == "inline" then
    M._show_inline_highlight(suggestion, bufnr)
  elseif display_type == "both" then
    M._show_float_window(suggestion, bufnr)
    M._show_inline_highlight(suggestion, bufnr)
  end
  
  -- è®¾ç½®è‡ªåŠ¨éšè—å®šæ—¶å™¨
  if display_state.config.timeout > 0 then
    vim.defer_fn(function()
      M.hide_current_suggestion()
    end, display_state.config.timeout)
  end
  
  return true
end

-- æ˜¾ç¤ºæµ®åŠ¨çª—å£
function M._show_float_window(suggestion, bufnr)
  local content = M._format_suggestion_content(suggestion)
  local width = math.max(40, math.min(80, #content[1] + 4))
  local height = #content + 2
  
  -- è·å–å…‰æ ‡ä½ç½®
  local cursor = api.nvim_win_get_cursor(0)
  local row = cursor[1]
  local col = cursor[2]
  
  -- è®¡ç®—çª—å£ä½ç½®
  local win_config = {
    relative = "cursor",
    row = 1,
    col = 0,
    width = width,
    height = height,
    style = "minimal",
    border = "rounded",
    focusable = false,
    zindex = 100
  }
  
  -- åˆ›å»ºç¼“å†²åŒº
  local float_bufnr = api.nvim_create_buf(false, true)
  api.nvim_buf_set_lines(float_bufnr, 0, -1, false, content)
  api.nvim_buf_set_option(float_bufnr, "modifiable", false)
  api.nvim_buf_set_option(float_bufnr, "filetype", "copilot-nes")
  
  -- åˆ›å»ºçª—å£
  local win_id = api.nvim_open_win(float_bufnr, false, win_config)
  
  -- è®¾ç½®çª—å£é€‰é¡¹
  api.nvim_win_set_option(win_id, "winhl", "Normal:CopilotNESText,FloatBorder:CopilotNESBorder")
  
  -- æ·»åŠ è¯­æ³•é«˜äº®
  M._add_float_syntax(float_bufnr)
  
  -- ä¿å­˜çª—å£å¼•ç”¨
  display_state.active_windows[suggestion.id] = {
    win_id = win_id,
    bufnr = float_bufnr
  }
  
  logger.debug("Float window created for suggestion: " .. suggestion.id)
end

-- æ ¼å¼åŒ–å»ºè®®å†…å®¹
function M._format_suggestion_content(suggestion)
  local content = {}
  
  -- æ ‡é¢˜è¡Œ
  table.insert(content, "ğŸ“ Next Edit Suggestion")
  table.insert(content, "")
  
  -- æè¿°
  if suggestion.description and #suggestion.description > 0 then
    table.insert(content, "Description: " .. suggestion.description)
  end
  
  -- ç½®ä¿¡åº¦
  local confidence_percent = math.floor(suggestion.confidence * 100)
  table.insert(content, "Confidence: " .. confidence_percent .. "%")
  
  -- å»ºè®®æ–‡æœ¬é¢„è§ˆ
  if suggestion.new_text and #suggestion.new_text > 0 then
    table.insert(content, "")
    table.insert(content, "Suggested change:")
    
    -- é™åˆ¶é¢„è§ˆé•¿åº¦
    local preview = suggestion.new_text
    if #preview > 50 then
      preview = preview:sub(1, 47) .. "..."
    end
    table.insert(content, "  " .. preview)
  end
  
  -- æ“ä½œæç¤º
  table.insert(content, "")
  table.insert(content, "Press <C-y> to accept, <C-n> to reject")
  
  return content
end

-- æ·»åŠ æµ®åŠ¨çª—å£è¯­æ³•é«˜äº®
function M._add_float_syntax(bufnr)
  local syntax_commands = {
    "syntax match CopilotNESTitle /ğŸ“ Next Edit Suggestion/",
    "syntax match CopilotNESDescription /Description:.*/",
    "syntax match CopilotNESConfidence /Confidence:.*/",
    "syntax region CopilotNESCode start=/Suggested change:/ end=/Press.*/"
  }
  
  for _, cmd in ipairs(syntax_commands) do
    api.nvim_buf_call(bufnr, function()
      vim.cmd(cmd)
    end)
  end
end

-- æ˜¾ç¤ºå†…è”é«˜äº®
function M._show_inline_highlight(suggestion, bufnr)
  local range = suggestion.range
  if not range then return end
  
  local start_line = range.start.line
  local start_char = range.start.character
  local end_line = range["end"].line
  local end_char = range["end"].character
  
  -- æ·»åŠ é«˜äº®
  local highlight_id = api.nvim_buf_add_highlight(
    bufnr,
    display_state.namespace_id,
    "CopilotNESRange",
    start_line,
    start_char,
    end_char
  )
  
  -- ä¿å­˜é«˜äº®å¼•ç”¨
  display_state.active_highlights[suggestion.id] = {
    bufnr = bufnr,
    highlight_id = highlight_id,
    range = range
  }
  
  logger.debug("Inline highlight created for suggestion: " .. suggestion.id)
end

-- éšè—å½“å‰å»ºè®®
function M.hide_current_suggestion()
  if not display_state.current_suggestion then
    return
  end
  
  local suggestion_id = display_state.current_suggestion.id
  
  -- éšè—æµ®åŠ¨çª—å£
  M._hide_float_window(suggestion_id)
  
  -- éšè—å†…è”é«˜äº®
  M._hide_inline_highlight(suggestion_id)
  
  display_state.current_suggestion = nil
  logger.debug("Hidden suggestion: " .. suggestion_id)
end

-- éšè—æµ®åŠ¨çª—å£
function M._hide_float_window(suggestion_id)
  local window_info = display_state.active_windows[suggestion_id]
  if window_info then
    if api.nvim_win_is_valid(window_info.win_id) then
      api.nvim_win_close(window_info.win_id, true)
    end
    if api.nvim_buf_is_valid(window_info.bufnr) then
      api.nvim_buf_delete(window_info.bufnr, { force = true })
    end
    display_state.active_windows[suggestion_id] = nil
  end
end

-- éšè—å†…è”é«˜äº®
function M._hide_inline_highlight(suggestion_id)
  local highlight_info = display_state.active_highlights[suggestion_id]
  if highlight_info then
    api.nvim_buf_clear_namespace(
      highlight_info.bufnr,
      display_state.namespace_id,
      highlight_info.range.start.line,
      highlight_info.range["end"].line + 1
    )
    display_state.active_highlights[suggestion_id] = nil
  end
end

-- éšè—æ‰€æœ‰æ˜¾ç¤º
function M.hide_all()
  -- éšè—æ‰€æœ‰æµ®åŠ¨çª—å£
  for suggestion_id, _ in pairs(display_state.active_windows) do
    M._hide_float_window(suggestion_id)
  end
  
  -- éšè—æ‰€æœ‰å†…è”é«˜äº®
  for suggestion_id, _ in pairs(display_state.active_highlights) do
    M._hide_inline_highlight(suggestion_id)
  end
  
  display_state.current_suggestion = nil
end

-- æ›´æ–°å…‰æ ‡ä½ç½®
function M.update_cursor_position(bufnr)
  -- æ£€æŸ¥å½“å‰å»ºè®®æ˜¯å¦ä»ç„¶ç›¸å…³
  if display_state.current_suggestion then
    local cursor = api.nvim_win_get_cursor(0)
    local range = display_state.current_suggestion.range
    
    if not M._cursor_in_range(cursor, range) then
      -- å…‰æ ‡ç§»å‡ºå»ºè®®èŒƒå›´ï¼Œéšè—å»ºè®®
      M.hide_current_suggestion()
    end
  end
end

-- æ£€æŸ¥å…‰æ ‡æ˜¯å¦åœ¨èŒƒå›´å†…
function M._cursor_in_range(cursor, range)
  if not cursor or not range then return false end
  
  local line = cursor[1] - 1 -- è½¬æ¢ä¸º 0 åŸºç´¢å¼•
  local char = cursor[2]
  
  local start_line = range.start.line
  local start_char = range.start.character
  local end_line = range["end"].line
  local end_char = range["end"].character
  
  -- æ£€æŸ¥è¡ŒèŒƒå›´
  if line < start_line or line > end_line then
    return false
  end
  
  -- æ£€æŸ¥å­—ç¬¦èŒƒå›´
  if line == start_line and char < start_char then
    return false
  end
  
  if line == end_line and char > end_char then
    return false
  end
  
  return true
end

return M
```

### é”®ç›˜æ˜ å°„å¤„ç†å™¨

é”®ç›˜æ˜ å°„å¤„ç†å™¨è´Ÿè´£å¤„ç†ç”¨æˆ·çš„é”®ç›˜è¾“å…¥ï¼Œæä¾›ä¾¿æ·çš„å»ºè®®æ“ä½œæ–¹å¼ï¼š

```lua
-- lua/copilot/nes/handlers.lua
local M = {}

local manager = require("copilot.nes.manager")
local display = require("copilot.nes.display")
local lsp_client = require("copilot.nes.lsp_client")

-- å¤„ç†å™¨çŠ¶æ€
local handler_state = {
  config = {},
  keymaps_set = false
}

-- åˆå§‹åŒ–å¤„ç†å™¨
function M.setup(config)
  handler_state.config = config
  M._setup_keymaps(config.keymaps)
  logger.info("NES handlers initialized")
end

-- è®¾ç½®é”®ç›˜æ˜ å°„
function M._setup_keymaps(keymaps)
  if handler_state.keymaps_set then
    return
  end
  
  -- æ¥å—å»ºè®®
  if keymaps.accept then
    vim.keymap.set("n", keymaps.accept, function()
      M.accept_current_suggestion()
    end, {
      desc = "Accept Next Edit Suggestion",
      silent = true
    })
  end
  
  -- æ‹’ç»å»ºè®®
  if keymaps.reject then
    vim.keymap.set("n", keymaps.reject, function()
      M.reject_current_suggestion()
    end, {
      desc = "Reject Next Edit Suggestion",
      silent = true
    })
  end
  
  -- ä¸‹ä¸€ä¸ªå»ºè®®
  if keymaps.next then
    vim.keymap.set("n", keymaps.next, function()
      M.next_suggestion()
    end, {
      desc = "Next Edit Suggestion",
      silent = true
    })
  end
  
  -- ä¸Šä¸€ä¸ªå»ºè®®
  if keymaps.prev then
    vim.keymap.set("n", keymaps.prev, function()
      M.prev_suggestion()
    end, {
      desc = "Previous Edit Suggestion",
      silent = true
    })
  end
  
  -- åˆ‡æ¢ NES åŠŸèƒ½
  if keymaps.toggle then
    vim.keymap.set("n", keymaps.toggle, function()
      M.toggle_nes()
    end, {
      desc = "Toggle Next Edit Suggestions",
      silent = true
    })
  end
  
  handler_state.keymaps_set = true
  logger.debug("NES keymaps configured")
end

-- æ¥å—å½“å‰å»ºè®®
function M.accept_current_suggestion()
  local nes = require("copilot.nes")
  local current_suggestion = nes.get_current_suggestion()
  
  if not current_suggestion then
    logger.debug("No current suggestion to accept")
    return false
  end
  
  local bufnr = vim.api.nvim_get_current_buf()
  local client_id = nes.get_client_id()
  
  if not client_id then
    logger.error("No LSP client available")
    return false
  end
  
  -- åº”ç”¨å»ºè®®åˆ°ç¼“å†²åŒº
  if M._apply_suggestion(current_suggestion, bufnr) then
    -- æ ‡è®°å»ºè®®ä¸ºå·²æ¥å—
    manager.accept_suggestion(current_suggestion.id, bufnr)
    
    -- å‘é€æ¥å—å‘½ä»¤åˆ°æœåŠ¡å™¨
    lsp_client.accept_suggestion(current_suggestion.id, bufnr, client_id)
    
    -- éšè—æ˜¾ç¤º
    display.hide_current_suggestion()
    
    logger.info("Suggestion accepted: " .. current_suggestion.id)
    return true
  end
  
  return false
end

-- åº”ç”¨å»ºè®®åˆ°ç¼“å†²åŒº
function M._apply_suggestion(suggestion, bufnr)
  local range = suggestion.range
  local new_text = suggestion.new_text
  
  if not range or not new_text then
    logger.error("Invalid suggestion data")
    return false
  end
  
  local start_line = range.start.line
  local start_char = range.start.character
  local end_line = range["end"].line
  local end_char = range["end"].character
  
  -- è·å–å½“å‰è¡Œå†…å®¹
  local lines = vim.api.nvim_buf_get_lines(bufnr, start_line, end_line + 1, false)
  
  if #lines == 0 then
    logger.error("No lines to modify")
    return false
  end
  
  -- æ„å»ºæ–°çš„è¡Œå†…å®¹
  local new_lines = {}
  
  if start_line == end_line then
    -- å•è¡Œæ›¿æ¢
    local line = lines[1]
    local before = line:sub(1, start_char)
    local after = line:sub(end_char + 1)
    table.insert(new_lines, before .. new_text .. after)
  else
    -- å¤šè¡Œæ›¿æ¢
    local first_line = lines[1]:sub(1, start_char) .. new_text
    local last_line = lines[#lines]:sub(end_char + 1)
    table.insert(new_lines, first_line .. last_line)
  end
  
  -- åº”ç”¨æ›´æ”¹
  vim.api.nvim_buf_set_lines(bufnr, start_line, end_line + 1, false, new_lines)
  
  return true
end

-- æ‹’ç»å½“å‰å»ºè®®
function M.reject_current_suggestion()
  local nes = require("copilot.nes")
  local current_suggestion = nes.get_current_suggestion()
  
  if not current_suggestion then
    logger.debug("No current suggestion to reject")
    return false
  end
  
  local bufnr = vim.api.nvim_get_current_buf()
  local client_id = nes.get_client_id()
  
  if not client_id then
    logger.error("No LSP client available")
    return false
  end
  
  -- æ ‡è®°å»ºè®®ä¸ºå·²æ‹’ç»
  manager.reject_suggestion(current_suggestion.id, bufnr)
  
  -- å‘é€æ‹’ç»å‘½ä»¤åˆ°æœåŠ¡å™¨
  lsp_client.reject_suggestion(current_suggestion.id, bufnr, client_id)
  
  -- éšè—æ˜¾ç¤º
  display.hide_current_suggestion()
  
  logger.info("Suggestion rejected: " .. current_suggestion.id)
  return true
end

-- åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå»ºè®®
function M.next_suggestion()
  local nes = require("copilot.nes")
  local bufnr = vim.api.nvim_get_current_buf()
  local suggestions = manager.get_suggestions(bufnr)
  
  if #suggestions == 0 then
    logger.debug("No suggestions available")
    return false
  end
  
  local current_suggestion = nes.get_current_suggestion()
  local next_index = 1
  
  if current_suggestion then
    -- æ‰¾åˆ°å½“å‰å»ºè®®çš„ç´¢å¼•
    for i, suggestion in ipairs(suggestions) do
      if suggestion.id == current_suggestion.id then
        next_index = (i % #suggestions) + 1
        break
      end
    end
  end
  
  local next_suggestion = suggestions[next_index]
  if next_suggestion then
    display.show_suggestion(next_suggestion, bufnr)
    logger.debug("Switched to next suggestion: " .. next_suggestion.id)
    return true
  end
  
  return false
end

-- åˆ‡æ¢åˆ°ä¸Šä¸€ä¸ªå»ºè®®
function M.prev_suggestion()
  local nes = require("copilot.nes")
  local bufnr = vim.api.nvim_get_current_buf()
  local suggestions = manager.get_suggestions(bufnr)
  
  if #suggestions == 0 then
    logger.debug("No suggestions available")
    return false
  end
  
  local current_suggestion = nes.get_current_suggestion()
  local prev_index = #suggestions
  
  if current_suggestion then
    -- æ‰¾åˆ°å½“å‰å»ºè®®çš„ç´¢å¼•
    for i, suggestion in ipairs(suggestions) do
      if suggestion.id == current_suggestion.id then
        prev_index = i == 1 and #suggestions or i - 1
        break
      end
    end
  end
  
  local prev_suggestion = suggestions[prev_index]
  if prev_suggestion then
    display.show_suggestion(prev_suggestion, bufnr)
    logger.debug("Switched to previous suggestion: " .. prev_suggestion.id)
    return true
  end
  
  return false
end

-- åˆ‡æ¢ NES åŠŸèƒ½
function M.toggle_nes()
  local nes = require("copilot.nes")
  local enabled = nes.is_enabled()
  
  if enabled then
    nes.disable()
    logger.info("NES disabled")
  else
    nes.enable()
    logger.info("NES enabled")
  end
  
  return not enabled
end

return M
```

## é…ç½®ç³»ç»Ÿ

é…ç½®ç³»ç»Ÿæ˜¯ NES åŠŸèƒ½çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œå®ƒæä¾›äº†çµæ´»çš„é…ç½®é€‰é¡¹ï¼Œå…è®¸ç”¨æˆ·æ ¹æ®ä¸ªäººåå¥½å’Œä½¿ç”¨åœºæ™¯è‡ªå®šä¹‰ NES åŠŸèƒ½çš„è¡Œä¸ºã€‚

### é…ç½®ç»“æ„è®¾è®¡

```lua
-- lua/copilot/nes/config.lua
local M = {}

-- é»˜è®¤é…ç½®
local default_config = {
  -- åŸºæœ¬è®¾ç½®
  enabled = true,
  auto_trigger = true,
  debounce = 500, -- é˜²æŠ–å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
  max_suggestions = 5, -- æœ€å¤§å»ºè®®æ•°é‡
  
  -- æ˜¾ç¤ºè®¾ç½®
  display = {
    type = "float", -- "float", "inline", "both"
    auto_show = true, -- è‡ªåŠ¨æ˜¾ç¤ºå»ºè®®
    timeout = 5000, -- å»ºè®®è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    
    -- æµ®åŠ¨çª—å£è®¾ç½®
    float = {
      border = "rounded", -- è¾¹æ¡†æ ·å¼
      max_width = 80,
      max_height = 20,
      zindex = 100
    },
    
    -- å†…è”é«˜äº®è®¾ç½®
    inline = {
      highlight_group = "CopilotNESRange",
      show_description = true
    }
  },
  
  -- é”®ç›˜æ˜ å°„
  keymaps = {
    accept = "<C-y>",
    reject = "<C-n>",
    next = "<C-]>",
    prev = "<C-[>",
    toggle = "<leader>cn",
    show_info = "<leader>ci"
  },
  
  -- è¿‡æ»¤è®¾ç½®
  filter = {
    min_confidence = 0.5, -- æœ€å°ç½®ä¿¡åº¦
    max_suggestions_per_line = 1, -- æ¯è¡Œæœ€å¤§å»ºè®®æ•°
    exclude_filetypes = { -- æ’é™¤çš„æ–‡ä»¶ç±»å‹
      "help", "alpha", "dashboard", "neo-tree", "Trouble", "lazy"
    },
    exclude_buftypes = { -- æ’é™¤çš„ç¼“å†²åŒºç±»å‹
      "terminal", "prompt", "nofile"
    }
  },
  
  -- æ€§èƒ½è®¾ç½®
  performance = {
    max_file_size = 1024 * 1024, -- æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    cache_size = 100, -- ç¼“å­˜å¤§å°
    cleanup_interval = 30000 -- æ¸…ç†é—´éš”ï¼ˆæ¯«ç§’ï¼‰
  },
  
  -- æ—¥å¿—è®¾ç½®
  logging = {
    level = "info", -- "debug", "info", "warn", "error"
    file = nil -- æ—¥å¿—æ–‡ä»¶è·¯å¾„ï¼Œnil è¡¨ç¤ºä½¿ç”¨é»˜è®¤
  }
}

-- å½“å‰é…ç½®
local current_config = {}

-- åˆå§‹åŒ–é…ç½®
function M.setup(user_config)
  current_config = vim.tbl_deep_extend("force", default_config, user_config or {})
  
  -- éªŒè¯é…ç½®
  if not M.validate(current_config) then
    logger.error("Invalid NES configuration, using defaults")
    current_config = vim.deepcopy(default_config)
  end
  
  logger.info("NES configuration initialized")
  return current_config
end

-- è·å–é…ç½®
function M.get(key)
  if key then
    return vim.tbl_get(current_config, unpack(vim.split(key, ".", { plain = true })))
  else
    return vim.deepcopy(current_config)
  end
end

-- è®¾ç½®é…ç½®
function M.set(key, value)
  local keys = vim.split(key, ".", { plain = true })
  local config = current_config
  
  for i = 1, #keys - 1 do
    if not config[keys[i]] then
      config[keys[i]] = {}
    end
    config = config[keys[i]]
  end
  
  config[keys[#keys]] = value
  
  -- éªŒè¯æ›´æ–°åçš„é…ç½®
  if not M.validate(current_config) then
    logger.error("Invalid configuration value for: " .. key)
    return false
  end
  
  logger.debug("Configuration updated: " .. key .. " = " .. vim.inspect(value))
  return true
end

-- éªŒè¯é…ç½®
function M.validate(config)
  -- éªŒè¯åŸºæœ¬ç±»å‹
  if type(config.enabled) ~= "boolean" then
    logger.error("config.enabled must be boolean")
    return false
  end
  
  if type(config.auto_trigger) ~= "boolean" then
    logger.error("config.auto_trigger must be boolean")
    return false
  end
  
  if type(config.debounce) ~= "number" or config.debounce < 0 then
    logger.error("config.debounce must be non-negative number")
    return false
  end
  
  if type(config.max_suggestions) ~= "number" or config.max_suggestions < 1 then
    logger.error("config.max_suggestions must be positive number")
    return false
  end
  
  -- éªŒè¯æ˜¾ç¤ºé…ç½®
  if config.display then
    local valid_types = { "float", "inline", "both" }
    if not vim.tbl_contains(valid_types, config.display.type) then
      logger.error("config.display.type must be one of: " .. table.concat(valid_types, ", "))
      return false
    end
    
    if type(config.display.timeout) ~= "number" or config.display.timeout < 0 then
      logger.error("config.display.timeout must be non-negative number")
      return false
    end
  end
  
  -- éªŒè¯è¿‡æ»¤é…ç½®
  if config.filter then
    if type(config.filter.min_confidence) ~= "number" or 
       config.filter.min_confidence < 0 or config.filter.min_confidence > 1 then
      logger.error("config.filter.min_confidence must be between 0 and 1")
      return false
    end
  end
  
  return true
end

-- é‡ç½®é…ç½®
function M.reset()
  current_config = vim.deepcopy(default_config)
  logger.info("NES configuration reset to defaults")
  return current_config
end

-- å¯¼å‡ºé…ç½®
function M.export()
  return vim.inspect(current_config)
end

-- å¯¼å…¥é…ç½®
function M.import(config_str)
  local ok, config = pcall(loadstring("return " .. config_str))
  if not ok or type(config) ~= "table" then
    logger.error("Invalid configuration string")
    return false
  end
  
  if M.validate(config) then
    current_config = config
    logger.info("Configuration imported successfully")
    return true
  else
    logger.error("Imported configuration is invalid")
    return false
  end
end

return M
```

### é…ç½®é›†æˆåˆ°ä¸»æ’ä»¶

ä¸ºäº†å°† NES é…ç½®é›†æˆåˆ°ä¸» copilot.lua æ’ä»¶ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹ä¸»é…ç½®æ–‡ä»¶ï¼š

```lua
-- åœ¨ lua/copilot/config.lua ä¸­æ·»åŠ  NES é…ç½®æ”¯æŒ

-- æ‰©å±•é»˜è®¤é…ç½®
local original_defaults = {
  -- ç°æœ‰é…ç½®...
}

-- æ·»åŠ  NES é»˜è®¤é…ç½®
original_defaults.next_edit_suggestions = {
  enabled = false, -- é»˜è®¤ç¦ç”¨ï¼Œè®©ç”¨æˆ·ä¸»åŠ¨å¯ç”¨
  auto_trigger = true,
  debounce = 500,
  max_suggestions = 3,
  display = {
    type = "float",
    auto_show = true,
    timeout = 5000
  },
  keymaps = {
    accept = "<C-y>",
    reject = "<C-n>",
    next = "<C-]>",
    prev = "<C-[>",
    toggle = "<leader>cn"
  },
  filter = {
    min_confidence = 0.6,
    exclude_filetypes = { "help", "alpha", "dashboard" }
  }
}

-- æ‰©å±• setup å‡½æ•°
local original_setup = M.setup
function M.setup(opts)
  -- è°ƒç”¨åŸå§‹ setup
  local result = original_setup(opts)
  
  -- åˆå§‹åŒ– NES é…ç½®
  if opts and opts.next_edit_suggestions then
    local nes_config = opts.next_edit_suggestions
    if nes_config.enabled then
      -- åˆå§‹åŒ– NES åŠŸèƒ½
      local nes = require("copilot.nes")
      nes.setup(nes_config)
    end
  end
  
  return result
end
```

## å®‰è£…å’Œé…ç½®

### å®‰è£…æ­¥éª¤

#### 1. ç¯å¢ƒå‡†å¤‡

é¦–å…ˆç¡®ä¿æ‚¨çš„ç¯å¢ƒæ»¡è¶³å‰ç½®è¦æ±‚ï¼š

```bash
# æ£€æŸ¥ Neovim ç‰ˆæœ¬ï¼ˆéœ€è¦ 0.10.0+ï¼‰
nvim --version

# æ£€æŸ¥ Node.js ç‰ˆæœ¬ï¼ˆéœ€è¦ v20+ï¼‰
node --version

# å®‰è£…æˆ–æ›´æ–° GitHub Copilot Language Server
npm install -g @github/copilot-language-server@latest
```

#### 2. æ’ä»¶å®‰è£…

å¦‚æœæ‚¨ä½¿ç”¨ lazy.nvim ä½œä¸ºæ’ä»¶ç®¡ç†å™¨ï¼š

```lua
-- åœ¨æ‚¨çš„ Neovim é…ç½®ä¸­æ·»åŠ 
{
  "zbirenbaum/copilot.lua",
  cmd = "Copilot",
  event = "InsertEnter",
  config = function()
    require("copilot").setup({
      -- ç°æœ‰ copilot.lua é…ç½®...
      
      -- æ·»åŠ  NES é…ç½®
      next_edit_suggestions = {
        enabled = true,
        auto_trigger = true,
        debounce = 500,
        max_suggestions = 3,
        display = {
          type = "float", -- æˆ– "inline", "both"
          auto_show = true,
          timeout = 5000
        },
        keymaps = {
          accept = "<C-y>",
          reject = "<C-n>",
          next = "<C-]>",
          prev = "<C-[>",
          toggle = "<leader>cn"
        },
        filter = {
          min_confidence = 0.6,
          exclude_filetypes = { "help", "alpha", "dashboard" }
        }
      }
    })
  end,
}
```

#### 3. ä»£ç é›†æˆ

å°†æœ¬æŒ‡å—ä¸­æä¾›çš„ä»£ç æ–‡ä»¶æ·»åŠ åˆ°æ‚¨çš„ copilot.lua æ’ä»¶ç›®å½•ä¸­ï¼š

```
lua/copilot/
â”œâ”€â”€ nes/
â”‚   â”œâ”€â”€ init.lua          # NES ä¸»æ¨¡å—
â”‚   â”œâ”€â”€ manager.lua       # å»ºè®®ç®¡ç†å™¨
â”‚   â”œâ”€â”€ display.lua       # æ˜¾ç¤ºæ§åˆ¶å™¨
â”‚   â”œâ”€â”€ handlers.lua      # äº‹ä»¶å¤„ç†å™¨
â”‚   â”œâ”€â”€ lsp_client.lua    # LSP å®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ config.lua        # é…ç½®ç®¡ç†
â”‚   â””â”€â”€ protocol_adapter.lua # åè®®é€‚é…å™¨
â””â”€â”€ lsp/
    â””â”€â”€ init.lua          # æ‰©å±•ç°æœ‰ LSP é›†æˆ
```

### åŸºæœ¬é…ç½®ç¤ºä¾‹

#### æœ€å°é…ç½®

```lua
require("copilot").setup({
  next_edit_suggestions = {
    enabled = true
  }
})
```

#### æ¨èé…ç½®

```lua
require("copilot").setup({
  next_edit_suggestions = {
    enabled = true,
    auto_trigger = true,
    debounce = 300,
    max_suggestions = 5,
    display = {
      type = "both", -- åŒæ—¶æ˜¾ç¤ºæµ®åŠ¨çª—å£å’Œå†…è”é«˜äº®
      auto_show = true,
      timeout = 8000,
      float = {
        border = "rounded",
        max_width = 60
      }
    },
    keymaps = {
      accept = "<C-y>",
      reject = "<C-n>",
      next = "<Tab>",
      prev = "<S-Tab>",
      toggle = "<leader>ct",
      show_info = "<leader>ci"
    },
    filter = {
      min_confidence = 0.7,
      max_suggestions_per_line = 1,
      exclude_filetypes = { 
        "help", "alpha", "dashboard", "neo-tree", 
        "Trouble", "lazy", "mason", "notify"
      }
    }
  }
})
```

#### é«˜çº§é…ç½®

```lua
require("copilot").setup({
  next_edit_suggestions = {
    enabled = true,
    auto_trigger = true,
    debounce = 200,
    max_suggestions = 10,
    display = {
      type = "float",
      auto_show = false, -- æ‰‹åŠ¨æ˜¾ç¤º
      timeout = 0, -- ä¸è‡ªåŠ¨éšè—
      float = {
        border = "double",
        max_width = 100,
        max_height = 30,
        zindex = 200
      },
      inline = {
        highlight_group = "CopilotNESRange",
        show_description = true
      }
    },
    keymaps = {
      accept = "<C-CR>",
      reject = "<C-BS>",
      next = "<C-j>",
      prev = "<C-k>",
      toggle = "<F2>",
      show_info = "<F3>"
    },
    filter = {
      min_confidence = 0.5,
      max_suggestions_per_line = 2,
      exclude_filetypes = {},
      exclude_buftypes = { "terminal", "prompt" }
    },
    performance = {
      max_file_size = 2 * 1024 * 1024, -- 2MB
      cache_size = 200,
      cleanup_interval = 15000
    },
    logging = {
      level = "debug",
      file = vim.fn.stdpath("log") .. "/copilot-nes.log"
    }
  }
})
```


## ä½¿ç”¨æŒ‡å—

### åŸºæœ¬ä½¿ç”¨æµç¨‹

#### 1. å¯åŠ¨å’Œåˆå§‹åŒ–

å½“æ‚¨æ‰“å¼€ Neovim å¹¶å¼€å§‹ç¼–è¾‘ä»£ç æ—¶ï¼ŒNES åŠŸèƒ½ä¼šè‡ªåŠ¨åˆå§‹åŒ–ã€‚æ‚¨å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼éªŒè¯ NES æ˜¯å¦æ­£å¸¸å·¥ä½œï¼š

```vim
:lua print(require("copilot.nes").is_enabled())
```

å¦‚æœè¿”å› `true`ï¼Œè¯´æ˜ NES åŠŸèƒ½å·²å¯ç”¨ã€‚

#### 2. è§¦å‘å»ºè®®

NES å»ºè®®ä¼šåœ¨ä»¥ä¸‹æƒ…å†µä¸‹è‡ªåŠ¨è§¦å‘ï¼š

- **æ–‡æœ¬ä¿®æ”¹**: å½“æ‚¨ä¿®æ”¹ä»£ç æ—¶ï¼ŒNES ä¼šåˆ†æä¸Šä¸‹æ–‡å¹¶ç”Ÿæˆç›¸å…³å»ºè®®
- **å…‰æ ‡ç§»åŠ¨**: ç§»åŠ¨åˆ°ä¸åŒçš„ä»£ç ä½ç½®å¯èƒ½è§¦å‘æ–°çš„å»ºè®®
- **æ‰‹åŠ¨è§¦å‘**: ä½¿ç”¨é…ç½®çš„å¿«æ·é”®æ‰‹åŠ¨è¯·æ±‚å»ºè®®

#### 3. æŸ¥çœ‹å»ºè®®

æ ¹æ®æ‚¨çš„é…ç½®ï¼Œå»ºè®®ä¼šä»¥ä¸åŒæ–¹å¼æ˜¾ç¤ºï¼š

**æµ®åŠ¨çª—å£æ¨¡å¼**: å»ºè®®ä»¥æµ®åŠ¨çª—å£å½¢å¼æ˜¾ç¤ºåœ¨å…‰æ ‡é™„è¿‘ï¼ŒåŒ…å«è¯¦ç»†çš„å»ºè®®ä¿¡æ¯å’Œæ“ä½œæç¤ºã€‚

**å†…è”é«˜äº®æ¨¡å¼**: å»ºè®®çš„æ–‡æœ¬èŒƒå›´ä¼šè¢«é«˜äº®æ˜¾ç¤ºï¼Œæ‚¨å¯ä»¥çœ‹åˆ°å“ªäº›ä»£ç ä¼šè¢«ä¿®æ”¹ã€‚

**æ··åˆæ¨¡å¼**: åŒæ—¶æ˜¾ç¤ºæµ®åŠ¨çª—å£å’Œå†…è”é«˜äº®ï¼Œæä¾›æœ€å®Œæ•´çš„ä¿¡æ¯ã€‚

#### 4. æ“ä½œå»ºè®®

ä½¿ç”¨é…ç½®çš„å¿«æ·é”®æ“ä½œå»ºè®®ï¼š

- **æ¥å—å»ºè®®**: é»˜è®¤ `<C-y>`ï¼Œåº”ç”¨å»ºè®®åˆ°ä»£ç ä¸­
- **æ‹’ç»å»ºè®®**: é»˜è®¤ `<C-n>`ï¼Œæ‹’ç»å½“å‰å»ºè®®
- **ä¸‹ä¸€ä¸ªå»ºè®®**: é»˜è®¤ `<C-]>`ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå»ºè®®
- **ä¸Šä¸€ä¸ªå»ºè®®**: é»˜è®¤ `<C-[>`ï¼Œåˆ‡æ¢åˆ°ä¸Šä¸€ä¸ªå»ºè®®
- **åˆ‡æ¢åŠŸèƒ½**: é»˜è®¤ `<leader>cn`ï¼Œå¯ç”¨/ç¦ç”¨ NES åŠŸèƒ½

### å®é™…ä½¿ç”¨åœºæ™¯

#### åœºæ™¯ä¸€ï¼šé”™è¯¯ä¿®å¤

å½“æ‚¨çš„ä»£ç ä¸­å­˜åœ¨æ˜æ˜¾çš„é”™è¯¯æ—¶ï¼ŒNES ä¼šæä¾›ä¿®å¤å»ºè®®ï¼š

```python
# åŸå§‹ä»£ç ï¼ˆåŒ…å«æ‹¼å†™é”™è¯¯ï¼‰
def calcualte_sum(numbers):
    return sum(numbres)

# NES å»ºè®®ä¿®å¤
def calculate_sum(numbers):  # ä¿®å¤å‡½æ•°åæ‹¼å†™
    return sum(numbers)      # ä¿®å¤å˜é‡åæ‹¼å†™
```

**æ“ä½œæ­¥éª¤**:
1. å°†å…‰æ ‡ç§»åŠ¨åˆ°é”™è¯¯ä½ç½®
2. ç­‰å¾… NES å»ºè®®å‡ºç°ï¼ˆé€šå¸¸åœ¨ 500ms å†…ï¼‰
3. æŸ¥çœ‹å»ºè®®å†…å®¹å’Œç½®ä¿¡åº¦
4. æŒ‰ `<C-y>` æ¥å—å»ºè®®æˆ– `<C-n>` æ‹’ç»

#### åœºæ™¯äºŒï¼šä»£ç é‡æ„

NES å¯ä»¥å¸®åŠ©æ‚¨è¿›è¡Œä»£ç é‡æ„ï¼Œå¦‚å˜é‡é‡å‘½åã€å‡½æ•°æå–ç­‰ï¼š

```javascript
// åŸå§‹ä»£ç 
function processData(data) {
    let result = [];
    for (let i = 0; i < data.length; i++) {
        if (data[i] > 0) {
            result.push(data[i] * 2);
        }
    }
    return result;
}

// NES å»ºè®®é‡æ„ä¸ºæ›´ç°ä»£çš„å†™æ³•
function processData(data) {
    return data
        .filter(item => item > 0)
        .map(item => item * 2);
}
```

#### åœºæ™¯ä¸‰ï¼šä»£ç ä¼˜åŒ–

NES å¯ä»¥å»ºè®®æ€§èƒ½ä¼˜åŒ–å’Œæœ€ä½³å®è·µï¼š

```lua
-- åŸå§‹ä»£ç 
local function find_item(list, target)
    for i = 1, #list do
        if list[i] == target then
            return i
        end
    end
    return nil
end

-- NES å»ºè®®ä¼˜åŒ–
local function find_item(list, target)
    for i, item in ipairs(list) do  -- ä½¿ç”¨ ipairs æ›´é«˜æ•ˆ
        if item == target then
            return i
        end
    end
    return nil
end
```

### é«˜çº§ä½¿ç”¨æŠ€å·§

#### 1. è‡ªå®šä¹‰å¿«æ·é”®

æ‚¨å¯ä»¥æ ¹æ®ä¸ªäººä¹ æƒ¯è‡ªå®šä¹‰å¿«æ·é”®ï¼š

```lua
next_edit_suggestions = {
  keymaps = {
    accept = "<CR>",        -- ä½¿ç”¨å›è½¦æ¥å—
    reject = "<Esc>",       -- ä½¿ç”¨ Esc æ‹’ç»
    next = "<Tab>",         -- ä½¿ç”¨ Tab åˆ‡æ¢
    prev = "<S-Tab>",       -- ä½¿ç”¨ Shift+Tab åå‘åˆ‡æ¢
    toggle = "<F12>",       -- ä½¿ç”¨ F12 åˆ‡æ¢åŠŸèƒ½
    show_info = "<leader>?" -- æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
  }
}
```

#### 2. æ¡ä»¶è¿‡æ»¤

é…ç½®æ™ºèƒ½è¿‡æ»¤ä»¥æé«˜å»ºè®®è´¨é‡ï¼š

```lua
next_edit_suggestions = {
  filter = {
    min_confidence = 0.8,  -- åªæ˜¾ç¤ºé«˜ç½®ä¿¡åº¦å»ºè®®
    max_suggestions_per_line = 1,  -- æ¯è¡Œæœ€å¤šä¸€ä¸ªå»ºè®®
    exclude_filetypes = {
      "markdown", "text", "help"  -- æ’é™¤æ–‡æ¡£ç±»å‹
    },
    exclude_patterns = {
      "%.git/",  -- æ’é™¤ git ç›®å½•
      "node_modules/",  -- æ’é™¤ä¾èµ–ç›®å½•
      "%.min%.js$"  -- æ’é™¤å‹ç¼©æ–‡ä»¶
    }
  }
}
```

#### 3. æ€§èƒ½è°ƒä¼˜

é’ˆå¯¹å¤§å‹é¡¹ç›®ä¼˜åŒ–æ€§èƒ½ï¼š

```lua
next_edit_suggestions = {
  performance = {
    max_file_size = 500 * 1024,  -- é™åˆ¶æ–‡ä»¶å¤§å°ä¸º 500KB
    debounce = 1000,  -- å¢åŠ é˜²æŠ–æ—¶é—´åˆ° 1 ç§’
    cache_size = 50,  -- å‡å°‘ç¼“å­˜å¤§å°
    cleanup_interval = 10000  -- æ›´é¢‘ç¹çš„æ¸…ç†
  }
}
```

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆ

#### é—®é¢˜ 1: NES åŠŸèƒ½æ— æ³•å¯åŠ¨

**ç—‡çŠ¶**: é…ç½®äº† NES ä½†æ²¡æœ‰çœ‹åˆ°ä»»ä½•å»ºè®®

**å¯èƒ½åŸå› **:
- GitHub Copilot Language Server ç‰ˆæœ¬è¿‡ä½
- LSP å®¢æˆ·ç«¯æœªæ­£ç¡®è¿æ¥
- é…ç½®é”™è¯¯

**è§£å†³æ­¥éª¤**:

1. **æ£€æŸ¥æœåŠ¡å™¨ç‰ˆæœ¬**:
```bash
npm list -g @github/copilot-language-server
```
ç¡®ä¿ç‰ˆæœ¬ä¸º 1.337.0 æˆ–æ›´é«˜ã€‚

2. **æ£€æŸ¥ LSP è¿æ¥**:
```vim
:LspInfo
```
ç¡®è®¤ copilot LSP å®¢æˆ·ç«¯å·²è¿æ¥ã€‚

3. **æ£€æŸ¥é…ç½®**:
```lua
:lua print(vim.inspect(require("copilot.nes.config").get()))
```
éªŒè¯é…ç½®æ˜¯å¦æ­£ç¡®åŠ è½½ã€‚

4. **æŸ¥çœ‹æ—¥å¿—**:
```vim
:lua print(require("copilot.nes").get_logs())
```

#### é—®é¢˜ 2: å»ºè®®æ˜¾ç¤ºå¼‚å¸¸

**ç—‡çŠ¶**: å»ºè®®çª—å£ä½ç½®é”™è¯¯æˆ–æ˜¾ç¤ºä¸å®Œæ•´

**è§£å†³æ–¹æ¡ˆ**:

1. **é‡ç½®æ˜¾ç¤ºé…ç½®**:
```lua
require("copilot.nes.config").set("display.type", "float")
require("copilot.nes.display").refresh()
```

2. **æ¸…é™¤ç¼“å­˜**:
```lua
require("copilot.nes").clear_cache()
```

3. **é‡æ–°åˆå§‹åŒ–**:
```lua
require("copilot.nes").restart()
```

#### é—®é¢˜ 3: æ€§èƒ½é—®é¢˜

**ç—‡çŠ¶**: ç¼–è¾‘å™¨å“åº”ç¼“æ…¢ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤§æ–‡ä»¶ä¸­

**è§£å†³æ–¹æ¡ˆ**:

1. **è°ƒæ•´é˜²æŠ–æ—¶é—´**:
```lua
require("copilot.nes.config").set("debounce", 1000)
```

2. **é™åˆ¶æ–‡ä»¶å¤§å°**:
```lua
require("copilot.nes.config").set("performance.max_file_size", 100 * 1024)
```

3. **å‡å°‘å»ºè®®æ•°é‡**:
```lua
require("copilot.nes.config").set("max_suggestions", 2)
```

#### é—®é¢˜ 4: å¿«æ·é”®å†²çª

**ç—‡çŠ¶**: NES å¿«æ·é”®ä¸å…¶ä»–æ’ä»¶å†²çª

**è§£å†³æ–¹æ¡ˆ**:

1. **é‡æ–°æ˜ å°„å¿«æ·é”®**:
```lua
require("copilot.nes.config").set("keymaps.accept", "<C-CR>")
require("copilot.nes.config").set("keymaps.reject", "<C-BS>")
```

2. **ç¦ç”¨å†²çªçš„å¿«æ·é”®**:
```lua
require("copilot.nes.config").set("keymaps.accept", "")
```

### è°ƒè¯•å·¥å…·

#### 1. æ—¥å¿—æŸ¥çœ‹

å¯ç”¨è¯¦ç»†æ—¥å¿—è®°å½•ï¼š

```lua
require("copilot.nes.config").set("logging.level", "debug")
```

æŸ¥çœ‹æ—¥å¿—ï¼š

```vim
:lua require("copilot.nes").show_logs()
```

#### 2. çŠ¶æ€æ£€æŸ¥

æ£€æŸ¥ NES çŠ¶æ€ï¼š

```lua
:lua print(vim.inspect(require("copilot.nes").get_status()))
```

#### 3. è¯Šæ–­å‘½ä»¤

è¿è¡Œè¯Šæ–­ï¼š

```vim
:CopilotNESDiagnose
```

è¿™ä¸ªå‘½ä»¤ä¼šæ£€æŸ¥ï¼š
- LSP æœåŠ¡å™¨è¿æ¥çŠ¶æ€
- é…ç½®æœ‰æ•ˆæ€§
- æƒé™å’Œç½‘ç»œè¿æ¥
- æ€§èƒ½æŒ‡æ ‡

## æ€§èƒ½ä¼˜åŒ–

### ä¼˜åŒ–ç­–ç•¥

#### 1. æ™ºèƒ½é˜²æŠ–

å®ç°è‡ªé€‚åº”é˜²æŠ–æœºåˆ¶ï¼Œæ ¹æ®ç”¨æˆ·è¾“å…¥é¢‘ç‡åŠ¨æ€è°ƒæ•´å»¶è¿Ÿï¼š

```lua
-- åœ¨ manager.lua ä¸­æ·»åŠ è‡ªé€‚åº”é˜²æŠ–
local adaptive_debounce = {
  base_delay = 500,
  max_delay = 2000,
  min_delay = 100,
  recent_changes = {},
  window_size = 10
}

function adaptive_debounce:calculate_delay()
  local now = vim.loop.hrtime()
  local recent_count = 0
  
  -- æ¸…ç†è¿‡æœŸè®°å½•
  for i = #self.recent_changes, 1, -1 do
    if now - self.recent_changes[i] > 5000000000 then -- 5ç§’
      table.remove(self.recent_changes, i)
    else
      recent_count = recent_count + 1
    end
  end
  
  -- æ ¹æ®é¢‘ç‡è°ƒæ•´å»¶è¿Ÿ
  if recent_count > 5 then
    return math.min(self.max_delay, self.base_delay * 2)
  elseif recent_count < 2 then
    return math.max(self.min_delay, self.base_delay / 2)
  else
    return self.base_delay
  end
end

function adaptive_debounce:record_change()
  table.insert(self.recent_changes, vim.loop.hrtime())
  if #self.recent_changes > self.window_size then
    table.remove(self.recent_changes, 1)
  end
end
```

#### 2. å»ºè®®ç¼“å­˜

å®ç°æ™ºèƒ½ç¼“å­˜æœºåˆ¶ï¼Œé¿å…é‡å¤è¯·æ±‚ï¼š

```lua
-- åœ¨ manager.lua ä¸­æ·»åŠ ç¼“å­˜æœºåˆ¶
local suggestion_cache = {
  cache = {},
  max_size = 100,
  ttl = 30000 -- 30ç§’
}

function suggestion_cache:get_key(bufnr, position, context)
  return string.format("%d:%d:%d:%s", bufnr, position.line, position.character, 
                      vim.fn.sha256(context))
end

function suggestion_cache:get(key)
  local entry = self.cache[key]
  if entry and (vim.loop.hrtime() - entry.timestamp) < (self.ttl * 1000000) then
    return entry.suggestions
  end
  return nil
end

function suggestion_cache:set(key, suggestions)
  -- æ¸…ç†è¿‡æœŸæ¡ç›®
  self:cleanup()
  
  -- æ·»åŠ æ–°æ¡ç›®
  self.cache[key] = {
    suggestions = suggestions,
    timestamp = vim.loop.hrtime()
  }
  
  -- é™åˆ¶ç¼“å­˜å¤§å°
  if vim.tbl_count(self.cache) > self.max_size then
    self:evict_oldest()
  end
end

function suggestion_cache:cleanup()
  local now = vim.loop.hrtime()
  for key, entry in pairs(self.cache) do
    if (now - entry.timestamp) >= (self.ttl * 1000000) then
      self.cache[key] = nil
    end
  end
end
```

#### 3. å¼‚æ­¥å¤„ç†

ä½¿ç”¨ Neovim çš„å¼‚æ­¥ API é¿å…é˜»å¡ï¼š

```lua
-- åœ¨ lsp_client.lua ä¸­å®ç°å¼‚æ­¥å¤„ç†
function M.request_suggestions_async(bufnr, client_id, callback)
  vim.schedule(function()
    local client = vim.lsp.get_client_by_id(client_id)
    if not client then
      callback(nil, "LSP client not found")
      return
    end
    
    -- å¼‚æ­¥è·å–æ–‡æ¡£ä¿¡æ¯
    vim.defer_fn(function()
      local uri = vim.uri_from_bufnr(bufnr)
      local position = M._get_cursor_position()
      
      local params = {
        textDocument = { uri = uri },
        position = position
      }
      
      client.request("textDocument/nextEditSuggestions", params, function(err, result)
        vim.schedule(function()
          callback(result, err)
        end)
      end, bufnr)
    end, 0)
  end)
end
```

#### 4. å†…å­˜ç®¡ç†

å®ç°è‡ªåŠ¨å†…å­˜æ¸…ç†ï¼š

```lua
-- åœ¨ manager.lua ä¸­æ·»åŠ å†…å­˜ç®¡ç†
local memory_manager = {
  cleanup_timer = nil,
  cleanup_interval = 30000, -- 30ç§’
  max_memory_usage = 50 * 1024 * 1024 -- 50MB
}

function memory_manager:start()
  if self.cleanup_timer then
    return
  end
  
  self.cleanup_timer = vim.fn.timer_start(self.cleanup_interval, function()
    self:cleanup()
  end, { ["repeat"] = -1 })
end

function memory_manager:cleanup()
  -- æ¸…ç†è¿‡æœŸå»ºè®®
  for bufnr, suggestions in pairs(manager_state.suggestions) do
    local valid_suggestions = {}
    for _, suggestion in ipairs(suggestions) do
      if not suggestion:is_expired(30) then -- 30ç§’è¿‡æœŸ
        table.insert(valid_suggestions, suggestion)
      end
    end
    manager_state.suggestions[bufnr] = valid_suggestions
  end
  
  -- æ¸…ç†ç¼“å­˜
  suggestion_cache:cleanup()
  
  -- å¼ºåˆ¶åƒåœ¾å›æ”¶
  if self:get_memory_usage() > self.max_memory_usage then
    collectgarbage("collect")
  end
end

function memory_manager:get_memory_usage()
  return collectgarbage("count") * 1024
end
```

### æ€§èƒ½ç›‘æ§

#### 1. æ€§èƒ½æŒ‡æ ‡æ”¶é›†

```lua
-- åœ¨ manager.lua ä¸­æ·»åŠ æ€§èƒ½ç›‘æ§
local performance_monitor = {
  metrics = {
    request_count = 0,
    request_time_total = 0,
    suggestion_count = 0,
    cache_hits = 0,
    cache_misses = 0
  },
  start_time = vim.loop.hrtime()
}

function performance_monitor:record_request(duration)
  self.metrics.request_count = self.metrics.request_count + 1
  self.metrics.request_time_total = self.metrics.request_time_total + duration
end

function performance_monitor:record_suggestions(count)
  self.metrics.suggestion_count = self.metrics.suggestion_count + count
end

function performance_monitor:record_cache_hit()
  self.metrics.cache_hits = self.metrics.cache_hits + 1
end

function performance_monitor:record_cache_miss()
  self.metrics.cache_misses = self.metrics.cache_misses + 1
end

function performance_monitor:get_stats()
  local uptime = (vim.loop.hrtime() - self.start_time) / 1000000000
  local avg_request_time = self.metrics.request_count > 0 and 
                          (self.metrics.request_time_total / self.metrics.request_count) or 0
  local cache_hit_rate = (self.metrics.cache_hits + self.metrics.cache_misses) > 0 and
                        (self.metrics.cache_hits / (self.metrics.cache_hits + self.metrics.cache_misses)) or 0
  
  return {
    uptime = uptime,
    requests_per_second = self.metrics.request_count / uptime,
    average_request_time = avg_request_time,
    total_suggestions = self.metrics.suggestion_count,
    cache_hit_rate = cache_hit_rate,
    memory_usage = collectgarbage("count") * 1024
  }
end
```

#### 2. æ€§èƒ½æŠ¥å‘Š

```vim
" æ·»åŠ ç”¨æˆ·å‘½ä»¤æŸ¥çœ‹æ€§èƒ½æŠ¥å‘Š
command! CopilotNESPerf lua require("copilot.nes").show_performance_report()
```

```lua
-- å®ç°æ€§èƒ½æŠ¥å‘Šå‡½æ•°
function M.show_performance_report()
  local stats = performance_monitor:get_stats()
  
  local report = {
    "=== Copilot NES Performance Report ===",
    "",
    string.format("Uptime: %.2f seconds", stats.uptime),
    string.format("Requests per second: %.2f", stats.requests_per_second),
    string.format("Average request time: %.2f ms", stats.average_request_time),
    string.format("Total suggestions: %d", stats.total_suggestions),
    string.format("Cache hit rate: %.2f%%", stats.cache_hit_rate * 100),
    string.format("Memory usage: %.2f MB", stats.memory_usage / 1024 / 1024),
    "",
    "=== Configuration ===",
    string.format("Debounce: %d ms", config.get("debounce")),
    string.format("Max suggestions: %d", config.get("max_suggestions")),
    string.format("Display type: %s", config.get("display.type")),
    string.format("Auto trigger: %s", config.get("auto_trigger") and "enabled" or "disabled")
  }
  
  -- æ˜¾ç¤ºæŠ¥å‘Š
  local bufnr = vim.api.nvim_create_buf(false, true)
  vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, report)
  vim.api.nvim_buf_set_option(bufnr, "modifiable", false)
  vim.api.nvim_buf_set_option(bufnr, "filetype", "copilot-nes-report")
  
  local win_id = vim.api.nvim_open_win(bufnr, true, {
    relative = "editor",
    width = 60,
    height = #report + 2,
    row = math.floor((vim.o.lines - #report) / 2),
    col = math.floor((vim.o.columns - 60) / 2),
    style = "minimal",
    border = "rounded",
    title = " Performance Report ",
    title_pos = "center"
  })
end
```

## æ‰©å±•å¼€å‘

### è‡ªå®šä¹‰å»ºè®®å¤„ç†å™¨

æ‚¨å¯ä»¥å¼€å‘è‡ªå®šä¹‰çš„å»ºè®®å¤„ç†å™¨æ¥æ‰©å±• NES åŠŸèƒ½ï¼š

```lua
-- lua/copilot/nes/custom_processor.lua
local M = {}

-- è‡ªå®šä¹‰å¤„ç†å™¨æ¥å£
local CustomProcessor = {}
CustomProcessor.__index = CustomProcessor

function CustomProcessor:new(name, config)
  local obj = {
    name = name,
    config = config or {},
    enabled = true
  }
  setmetatable(obj, self)
  return obj
end

-- å¤„ç†å»ºè®®çš„ä¸»è¦æ–¹æ³•
function CustomProcessor:process(suggestions, context)
  -- å®ç°è‡ªå®šä¹‰å¤„ç†é€»è¾‘
  local processed = {}
  
  for _, suggestion in ipairs(suggestions) do
    if self:should_process(suggestion, context) then
      local enhanced = self:enhance_suggestion(suggestion, context)
      table.insert(processed, enhanced)
    end
  end
  
  return processed
end

-- åˆ¤æ–­æ˜¯å¦åº”è¯¥å¤„ç†è¯¥å»ºè®®
function CustomProcessor:should_process(suggestion, context)
  -- å®ç°è‡ªå®šä¹‰è¿‡æ»¤é€»è¾‘
  return true
end

-- å¢å¼ºå»ºè®®å†…å®¹
function CustomProcessor:enhance_suggestion(suggestion, context)
  -- å®ç°å»ºè®®å¢å¼ºé€»è¾‘
  return suggestion
end

-- æ³¨å†Œè‡ªå®šä¹‰å¤„ç†å™¨
function M.register_processor(processor)
  local manager = require("copilot.nes.manager")
  manager.add_processor(processor)
end

return M
```

### æ’ä»¶é›†æˆç¤ºä¾‹

#### ä¸ nvim-cmp é›†æˆ

```lua
-- lua/copilot/nes/integrations/cmp.lua
local M = {}

function M.setup()
  local cmp = require("cmp")
  local nes = require("copilot.nes")
  
  -- æ·»åŠ  NES ä½œä¸º cmp æº
  local source = {}
  
  function source:get_trigger_characters()
    return { " ", "\t", "\n" }
  end
  
  function source:complete(params, callback)
    local bufnr = vim.api.nvim_get_current_buf()
    local suggestions = nes.get_suggestions(bufnr)
    
    local items = {}
    for _, suggestion in ipairs(suggestions) do
      table.insert(items, {
        label = suggestion.description or "NES Suggestion",
        kind = cmp.lsp.CompletionItemKind.Text,
        detail = suggestion.new_text,
        documentation = {
          kind = "markdown",
          value = string.format("**Confidence:** %.0f%%\n\n%s", 
                               suggestion.confidence * 100, 
                               suggestion.description or "")
        },
        data = { suggestion_id = suggestion.id }
      })
    end
    
    callback({ items = items })
  end
  
  function source:execute(completion_item, callback)
    local suggestion_id = completion_item.data.suggestion_id
    nes.accept_suggestion(suggestion_id)
    callback()
  end
  
  -- æ³¨å†Œæº
  cmp.register_source("copilot_nes", source)
end

return M
```

### API æ–‡æ¡£

#### æ ¸å¿ƒ API

```lua
-- ä¸»è¦ API æ¥å£
local nes = require("copilot.nes")

-- å¯ç”¨/ç¦ç”¨åŠŸèƒ½
nes.enable()
nes.disable()
nes.toggle()

-- å»ºè®®æ“ä½œ
nes.request_suggestions(bufnr)
nes.get_suggestions(bufnr)
nes.accept_suggestion(suggestion_id, bufnr)
nes.reject_suggestion(suggestion_id, bufnr)

-- çŠ¶æ€æŸ¥è¯¢
nes.is_enabled()
nes.get_status()
nes.get_stats()

-- é…ç½®ç®¡ç†
nes.get_config(key)
nes.set_config(key, value)
nes.reset_config()

-- äº‹ä»¶ç›‘å¬
nes.on("suggestion_received", callback)
nes.on("suggestion_accepted", callback)
nes.on("suggestion_rejected", callback)
```

#### äº‹ä»¶ç³»ç»Ÿ

```lua
-- äº‹ä»¶ç›‘å¬ç¤ºä¾‹
require("copilot.nes").on("suggestion_received", function(suggestions, bufnr)
  print(string.format("Received %d suggestions for buffer %d", #suggestions, bufnr))
end)

require("copilot.nes").on("suggestion_accepted", function(suggestion, bufnr)
  print("Accepted suggestion: " .. suggestion.description)
end)
```

## æ€»ç»“

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»äº†å¦‚ä½•åœ¨ zbirenbaum/copilot.lua æ’ä»¶ä¸­é›†æˆ GitHub Copilot Language Server çš„ Next Edit Suggestions åŠŸèƒ½ã€‚é€šè¿‡æ¨¡å—åŒ–çš„æ¶æ„è®¾è®¡ã€å®Œæ•´çš„ä»£ç å®ç°å’Œè¯¦ç»†çš„é…ç½®è¯´æ˜ï¼Œæ‚¨å¯ä»¥æˆåŠŸåœ°å°†è¿™ä¸€å¼ºå¤§çš„åŠŸèƒ½æ·»åŠ åˆ°æ‚¨çš„ Neovim ç¼–è¾‘ç¯å¢ƒä¸­ã€‚

### ä¸»è¦ç‰¹æ€§

- **æ™ºèƒ½é¢„æµ‹æ€§ç¼–è¾‘**: åŸºäºä¸Šä¸‹æ–‡çš„ä»£ç ä¿®æ”¹å»ºè®®
- **å¤šç§æ˜¾ç¤ºæ¨¡å¼**: æ”¯æŒæµ®åŠ¨çª—å£ã€å†…è”é«˜äº®å’Œæ··åˆæ˜¾ç¤º
- **çµæ´»çš„é…ç½®ç³»ç»Ÿ**: ä¸°å¯Œçš„é…ç½®é€‰é¡¹æ»¡è¶³ä¸åŒéœ€æ±‚
- **é«˜æ€§èƒ½è®¾è®¡**: å¼‚æ­¥å¤„ç†ã€æ™ºèƒ½ç¼“å­˜å’Œå†…å­˜ç®¡ç†
- **å¯æ‰©å±•æ¶æ„**: æ”¯æŒè‡ªå®šä¹‰å¤„ç†å™¨å’Œæ’ä»¶é›†æˆ

### åç»­å‘å±•

éšç€ GitHub Copilot Language Server çš„ä¸æ–­å‘å±•ï¼ŒNES åŠŸèƒ½ä¹Ÿä¼šæŒç»­æ”¹è¿›ã€‚å»ºè®®å®šæœŸæ›´æ–°ç›¸å…³ç»„ä»¶å¹¶å…³æ³¨æ–°åŠŸèƒ½çš„å‘å¸ƒã€‚

å¦‚æœæ‚¨åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­é‡åˆ°é—®é¢˜æˆ–æœ‰æ”¹è¿›å»ºè®®ï¼Œæ¬¢è¿å‚ä¸å¼€æºç¤¾åŒºçš„è®¨è®ºå’Œè´¡çŒ®ã€‚

---

**æ³¨æ„**: æœ¬æŒ‡å—åŸºäºå½“å‰å¯ç”¨çš„æŠ€æœ¯ä¿¡æ¯ç¼–å†™ã€‚ç”±äº GitHub Copilot Language Server çš„ Next Edit Suggestions åŠŸèƒ½ä»åœ¨å‘å±•ä¸­ï¼ŒæŸäº›å®ç°ç»†èŠ‚å¯èƒ½éœ€è¦æ ¹æ®å®é™…çš„ API è§„èŒƒè¿›è¡Œè°ƒæ•´ã€‚å»ºè®®åœ¨å®æ–½å‰æŸ¥é˜…æœ€æ–°çš„å®˜æ–¹æ–‡æ¡£å’Œ API è§„èŒƒã€‚

